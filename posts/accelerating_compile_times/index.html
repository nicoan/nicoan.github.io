<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Accelerating Rust compilation times: Dynamic linking, code generation and cache | Nico Antinori</title>
<meta name=keywords content><meta name=description content="Having a language that does a lot of checks at compile time is not free, it will impact compilation times. Luckily there are some things we can do to speed things up: Dynamic linking, be careful with code generation and caching dependencies.
Dynamic linking is a somewhat difficult thing to achieve in Rust but not impossible. The main reason is that at the time of writing this (Sept-Oct 2024) Rust does not have its own stable ABI and it must rely on the C binary representation (if we want to inter-operate with other languages or other Rust versions)."><meta name=author content="Nicolás Antinori"><link rel=canonical href=https://nicoan.github.io/posts/accelerating_compile_times/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://nicoan.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nicoan.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://nicoan.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://nicoan.github.io/apple-touch-icon.png><link rel=mask-icon href=https://nicoan.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://nicoan.github.io/posts/accelerating_compile_times/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Accelerating Rust compilation times: Dynamic linking, code generation and cache"><meta property="og:description" content="Having a language that does a lot of checks at compile time is not free, it will impact compilation times. Luckily there are some things we can do to speed things up: Dynamic linking, be careful with code generation and caching dependencies.
Dynamic linking is a somewhat difficult thing to achieve in Rust but not impossible. The main reason is that at the time of writing this (Sept-Oct 2024) Rust does not have its own stable ABI and it must rely on the C binary representation (if we want to inter-operate with other languages or other Rust versions)."><meta property="og:type" content="article"><meta property="og:url" content="https://nicoan.github.io/posts/accelerating_compile_times/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-02T12:00:00-03:00"><meta property="article:modified_time" content="2024-10-02T12:00:00-03:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Accelerating Rust compilation times: Dynamic linking, code generation and cache"><meta name=twitter:description content="Having a language that does a lot of checks at compile time is not free, it will impact compilation times. Luckily there are some things we can do to speed things up: Dynamic linking, be careful with code generation and caching dependencies.
Dynamic linking is a somewhat difficult thing to achieve in Rust but not impossible. The main reason is that at the time of writing this (Sept-Oct 2024) Rust does not have its own stable ABI and it must rely on the C binary representation (if we want to inter-operate with other languages or other Rust versions)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://nicoan.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Accelerating Rust compilation times: Dynamic linking, code generation and cache","item":"https://nicoan.github.io/posts/accelerating_compile_times/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Accelerating Rust compilation times: Dynamic linking, code generation and cache","name":"Accelerating Rust compilation times: Dynamic linking, code generation and cache","description":"Having a language that does a lot of checks at compile time is not free, it will impact compilation times. Luckily there are some things we can do to speed things up: Dynamic linking, be careful with code generation and caching dependencies.\nDynamic linking is a somewhat difficult thing to achieve in Rust but not impossible. The main reason is that at the time of writing this (Sept-Oct 2024) Rust does not have its own stable ABI and it must rely on the C binary representation (if we want to inter-operate with other languages or other Rust versions).","keywords":[],"articleBody":"Having a language that does a lot of checks at compile time is not free, it will impact compilation times. Luckily there are some things we can do to speed things up: Dynamic linking, be careful with code generation and caching dependencies.\nDynamic linking is a somewhat difficult thing to achieve in Rust but not impossible. The main reason is that at the time of writing this (Sept-Oct 2024) Rust does not have its own stable ABI and it must rely on the C binary representation (if we want to inter-operate with other languages or other Rust versions). This has some interesting consequences that we will explore in this post.\nCode generation is when the high level representation of the source code is turned into binary code that can be executed by the machine. Given that the rust compiler uses LLVM, the level of optimizations and the quantity of generated code will affect the compilation speed.\nWhat is Linking? Programs are usually divided into several modules and they have numerous dependencies. Linking is a compilation stage where all the compiled code of those modules needed by a program (and the code of the program itself) is made available in the final executable. We have two ways of linking a program: static and dynamic.\nStatic Linking All the code needed by a program (from external modules and the program itself) is put together in the final executable. This creates fat binaries but it makes the program portable.\nDynamic Linking This type of linking must be supported by the operating system (most, if not all of the major operating systems support this). In this approach, instead of containing all the code needed, the executable contains undefined symbols and a list of objects that contain the code for those symbols.\nThese objects, often referred to as libraries, are binary files used to share binary code between several programs. In Microsoft Windows those files are known as DLLs (dynamically-linked library) and in Unix operating systems (Linux, Mac OS, etc) are known as SOs (shred objects).\nWhen running a dynamically linked executable, the operating system loads the program code along with the libraries in memory and do the final linking.\nThis approach creates “thin” binaries and saves disk and memory space, since the code from the libraries are shared among several applications.\nDifferent linking modes in Rust There are several different linking modes that we can use, producing different kind of shared objects, but in this post we will focus only on one of them: dylib.\nIf we put this configuration in our library crates, the Rust compiler will generate a dynamic library that will be dynamically linked with our executable. Isn’t that what we need? Why do we have other configurations?1 Given that Rust does not have an stable ABI yet, there are no guarantees that the compiled libraries will work if we don’t compile the project with the same Rust version used for compiling the library.\nThis mode is suitable for a project where we have one or more library crates that are used by several binary crates (or other libraries). We will usually compile everything altogether the first time and then recompile only the things we change. If we change the Rust version, we need to recompile everything.\nCompilation stages To generate binary objects, Rust compiler must go through several different stages. I am not going to explain how a compiler works in detail, but having a general idea of what happens will help us identify places where we can work to optimize compile times.\nTo measure compilation times, we will use the built-in cargo tool called timings. This tool will generate a detailed HTML report showing how long every compilation unit takes to compile.\nFrom source code to intermediate representation In the timings report, the stages described below are pictured in light blue in the Grantt chart.\nLexing and parsing The compiler first performs the lexing and parsing stage, where lexing is transforming the source code into an stream of tokens and parsing is generating an AST (Abstract Syntax Tree) from those tokens.\nMacro expansion (generating valid Rust code from the macros) is also done at this stage.\nAST Lowering After the AST is created, it is converted into a High Level Intermediate Representation (HIR), this stage is called AST Lowering. In HIR the compiler does type inference, type checking and resolve traits.\nMIR Lowering When HIR is ready, then we enter the MIR lowering stage, that is, transforming HIR to Middle Level Representation (MIR). In this stage, the famous borrow checking is done, code monomorphization, and some optimizations that will improve code generation and compilation speed in that stage.\nCode generation This stage is pictured in purple in the Grantt chart. When we are here, the compiler already has everything represented in MIR. During this phase, the MIR is transformed into LLVM-IR (LLVM Intermediate Representation) and handled to LLVM.\nLLVM does a lot more of optimizations and generates the assembler and binary code that later is linked into the final object.\nIf you want to learn more about the compilation stages, check this article.\nReducing compile times The toy project In order to show how to optimize compiling times, we are going to use a toy project that consist in one library crate and 40 separate binaries that use the library. You may ask yourself: What kind of project has that structure?! It could be a server-less project containing several cloud functions (like AWS Lambdas) that share functionality through some library crates or some project that consist in several binaries (like GNU Core utilities).\nHow I get the timings The timings found on this posts are the last timing returned by cargo after running 10 times the same compilation, always doing cargo clean before executing cargo build [...]. I compile the project 10 times to verify that on average the compilation times are more or less the same.\nInitial compile times Here are the individual compile times for the toy project. This and further compilations were done in Debian 12, with an i7-6700K and 16GB DDR4 2600Mhz Ram 2:\nThe total time was\nFinished `release` profile [optimized] target(s) in 25.30s And the size of the binaries is about 3.5MB:\nls -l --block-size=KB ./target/release total 143262kB -rwxr-xr-x 2 nico nico 3489kB Sep 16 15:03 bin1 -rwxr-xr-x 2 nico nico 3489kB Sep 16 15:03 bin10 -rw-r--r-- 1 nico nico 1kB Sep 16 15:04 bin10.d -rwxr-xr-x 2 nico nico 3489kB Sep 16 15:03 bin11 -rw-r--r-- 1 nico nico 1kB Sep 16 15:04 bin11.d -rwxr-xr-x 2 nico nico 3489kB Sep 16 15:03 bin12 -rw-r--r-- 1 nico nico 1kB Sep 16 15:04 bin12.d -rwxr-xr-x 2 nico nico 3489kB Sep 16 15:03 bin13 The command used was cargo build --release --timings. You can check the source code of the toy project here.\nRemoving unnecessary dependencies It is common that in a project, the people involved usually forget about removing old dependencies. This happens because when projects are large, it is hard to know if a dependency is not used anymore. Luckily, we can use the -Wunused-crate-dependencies flag that tells us which dependencies are not being used by the crates inside the project. If we compile with RUSTFLAGS=-Wunused-crate-dependencies cargo build --release --timings we get the following output:\n... warning: external crate `actix` unused in `lib1`: remove the dependency or add `use actix as _;` | = note: requested on the command line with `-W unused-crate-dependencies` warning: external crate `serde_json` unused in `lib1`: remove the dependency or add `use serde_json as _;` warning: external crate `tokio` unused in `lib1`: remove the dependency or add `use tokio as _;` warning: `lib1` (lib) generated 3 warnings By removing the unused dependencies reported by the warnings, we reduced the total compilation time a little:\nFinished `release` profile [optimized] target(s) in 23.85s It is not much, but by not compiling those dependencies, we gained around 1.x seconds! To keep our project clean, we can use this flag in our CI/CD pipeline to warn us when we forget to remove an old dependency.\nYou can find the modifications made in this section here.\nRemoving unnecessary derives Macros create valid Rust code that then has to be parsed, transformed, validated and optimized. It may happen that you need to derive some trait, not because is used by productive code but is used by test code. It does not make sense to process that code in release builds.\nA nice “trick” to avoid processing that code in release builds is to derive it behind a cargo feature and only activate that feature in the [dev-dependencies] section of the Cargo.toml. The Cargo.toml from lib1 was changed this way:\n[package] name = \"lib1\" version = \"0.1.0\" edition = \"2021\" [dependencies] mockall = { workspace = true, optional = true } reqwest = { workspace = true } serde = { workspace = true } [features] tests = [\"dep:mockall\"] And we put behind the tests feature, all the code we do not need in production 3:\n#[cfg_attr(feature = \"tests\", mockall::automock)] pub trait Trait1 { fn fn1(); fn fn2(a: u16) -\u003e String; fn fn3(a: String) -\u003e u16; } ... #[derive(Serialize, Default)] #[cfg_attr(feature = \"tests\", derive(Deserialize, PartialEq, Eq, Debug))] pub struct Struct1 { pub f1: u8, pub f2: String, pub f3: HashMap\u003cString, String\u003e, pub f4: HashSet\u003cString\u003e, pub f5: Vec\u003cString\u003e, } ... #[derive(Deserialize, Default)] #[cfg_attr(feature = \"tests\", derive(Serialize, PartialEq, Eq, Debug))] pub struct Struct9 { pub f1: u8, pub f2: String, pub f3: HashMap\u003cString, String\u003e, pub f4: HashSet\u003cString\u003e, pub f5: Vec\u003cString\u003e, } Activating the feature will work for both unit and integration tests. Here are the compilation times after introducing the flag:\nAnd the total time:\nFinished release profile [optimized] target(s) in 21.58s By reducing the code generated by the derives and automock macros, Rust have less code to translate to intermediate representation (light blue), code to generate (purple) and optimize. The time reduction was huge, from an average of 4.x seconds to an average of 0.3 seconds.\nThe take-home lesson here is: do not take the auto generation of code. If you don’t need it in the production build, do not compile it.\nYou can find the modifications made in this section here.\nDynamic Linking Until now, the code contained in lib1 is statically linked to all the binaries in our project. Instead of repeating the code in every binary, we can use dynamic linking to have lib1 as a shared object, allowing the binaries to use the code without the need of having it embedded.\nWith dynamic linking we will not only achieve faster compile times, we will also get smaller binaries and, if there’s a bug in the library, we can fix it and deploy the shared object without the need of modifying the binaries (as long as we use the same Rust version used to compile the binaries).\nTo activate dynamic linking, we need to add to the lib1’s Cargo.toml the following lines at the end:\n[lib] crate-type = [\"dylib\"] And compile ithe project t with: RUSTFLAGS=\"-C prefer-dynamic\" cargo build --release --timings. Here are the compilation times with dynamic linking:\nThe compilation times for lib1 increased 4, but for binaries times reduced from an average of 0.8x to an average of 0.3x! They were also reduced in size: from 3489 kB to 12 kB!\nls -l --block-size=KB ./target/release total 7238kB -rwxr-xr-x 2 nico nico 12kB Sep 16 14:43 bin1 -rwxr-xr-x 2 nico nico 12kB Sep 16 14:43 bin10 -rw-r--r-- 1 nico nico 1kB Sep 16 14:43 bin10.d -rwxr-xr-x 2 nico nico 12kB Sep 16 14:43 bin11 -rw-r--r-- 1 nico nico 1kB Sep 16 14:43 bin11.d -rwxr-xr-x 2 nico nico 12kB Sep 16 14:43 bin12 ... drwxr-xr-x 2 nico nico 5kB Sep 16 14:43 incremental -rw-r--r-- 1 nico nico 1kB Sep 16 14:43 liblib1.d -rwxr-xr-x 2 nico nico 6555kB Sep 16 14:43 liblib1.so The total time was\nFinished `release` profile [optimized] target(s) in 19.74s If we check the libraries needed for any of our binaries, we are going to see a dependency with liblib1.so. ldd outputs “not found” because the shared object is located in the target directory at the moment of running the command and not in the usual paths where shared objects can be found (/lib, /usr/lib , /usr/local/lib) or in any of the paths listed in the LD_LIBRARY_PATH environment variable.\n$ ldd ./target/release/bin1 linux-vdso.so.1 (0x00007ffe573aa000) liblib1.so =\u003e not found libstd-52417a9a08ba8fb9.so =\u003e not found libgcc_s.so.1 =\u003e /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007fc19594a000) libc.so.6 =\u003e /lib/x86_64-linux-gnu/libc.so.6 (0x00007fc195769000) /lib64/ld-linux-x86-64.so.2 (0x00007fc195986000) You can find the modifications made in this section here.\nCache dependencies Most of the total compilation time was taken by the the project’s dependencies. In this section we are going to explore two ways those dependencies can be cached so we avoid recompiling them every time we build it. This is specially useful in a continuous integration/deployment environment, where we are constantly compiling the project but the dependencies rarely change.\nsccache sccache is a tool developed by Mozilla. It can be used with several compilers, not only rustc. It works as a wrapper of the compiler, chaching compiled things locally on disk and avoiding recompiling them if possible.\nTo install it, we can run:\n$ cargo install sccache Then, we can use it by wrapping the rustc compiler with the RUSTC_WRAPPER environment variable:\n$ RUSTC_WRAPPER=sccache RUSTFLAGS=\"-C prefer-dynamic\" cargo build --release --timings We compiled the project with the dynamic linking activated. The first compilation took around 23 seconds, 3.x seconds more than last compilation but, in the first one, sccache was caching the compiled dependencies. After running cargo clean and recompiling the project again we get:\nFinished `release` profile [optimized] target(s) in 6.54s So, we dropped from an average of 19.x seconds to an average of 6.5x seconds!\nCargo Chef cargo-chef is an awesome tool created by Luca Palmieri. It is designed to speed up compilation times when using containers to build the project. Basically, what it does under the hood is locate all the entry points of our workspace either for libs (lib.rs) or binaries (main.rs), remove all the code from them, leave some trivial code like\n// main.rs fn main() {} and compile the project. In other words, it avoids compiling the source code from the project. It just compiles the dependencies to cache them. In future compilations, the dependencies will be already cached, so only the project’s business logic will be compiled.\nAs stated in the official documentation and in a warning if you try to use it locally, this is designed to be used with containers because it leverages on the Docker’s layer cache mechanism to work. It is not recommended using it to compile the project locally.\nFor demonstration purposes, I modified the Dockerfile suggested in the official cargo chef documentation:\nFROM lukemathwalker/cargo-chef:latest-rust-1 AS chef WORKDIR /app FROM chef AS planner COPY . . RUN cargo chef prepare --recipe-path recipe.json FROM chef AS builder COPY --from=planner /app/recipe.json recipe.json # Build dependencies - this is the caching Docker layer! RUN CARGO_TARGET_DIR=/app/cache RUSTFLAGS=\"-C prefer-dynamic\" cargo chef cook --release --workspace --recipe-path recipe.json COPY . . ENTRYPOINT [\"/bin/sh\"] The image produced from this Dockerfile will contain all the project dependencies already cached in /app/cache directory. It is very important to use cargo chef with exactly the same configuration you are going to use to compile the project. Since we are using the dynamic linking branch for the demonstration, we must include the RUSTFLAGS=\"-C prefer-dynamic\" flag.\nHere are the steps I followed:\nBuild the image: docker build --tag chef . Enter the container: docker run -it chef Compile the project: CARGO_TARGET_DIR=/app/cache RUSTFLAGS=\"-C prefer-dynamic\" cargo build --release --workspace. The total compilation time is:\nFinished `release` profile [optimized] target(s) in 2.64s We’ve just compiled the whole project in 2.64s! This is a massive time reduction!\nSummary We started our compile time reduction journey with static linked binaries with a size of 3489kB and a total compilation time of 25.x seconds and we finished it with dynamically linked binaries with a size of 12kB and a total compilation time of 2.x seconds:\nModification Total time % Time reduction from original Original codebase 25.3s 0% Remove unused dependencies 23.85s 5.73% Remove unnecesary derives 21.58s 14.70% Dynamic Linking 19.74s 21.98% Dynamic Linking + sccache 6.54s 75.15% Dynamic Linking + cargo chef 2.64s 89.57% It is important to remember that all the steps include the modifications from the previous steps, with the exception of the caches, that use the dynamic linking branch but sccache and cargo chef are used separately.\nConclusion Sometimes when we are working on projects, deadlines are tight, product team need to release new features and we need to choose wisely on what we spend our time. If we are lucky enough to be in a team that saves time to work on technical debt, we should really use that oportunity to make the structural changes needed in the project to reduce the compilation times. This may sound obvious but not everyone agrees on what is important to solve first.\nWhen projects are small, compilation times are usually small or tolerable, so we don’t pay much attention. As it grows, compilation times may become a real bottleneck for development (imagine that deploying a new version to a dev environment takes an hour).\nTaking care of the compilation will save the whole team a lot of time and headaches, enabling everyone to develop, test and deploy faster.\nResources Learn how to setup dynamically loadable plugins for your Rust app Rust’s official Linkage page Linking Rust crates series Minimizing Compile Times Speeding up incremental Rust compilation with dylibs Build cache There’s a mode that we can use to avoid recompiling the library to match the Rust version we are currently using: cdylib . This mode will produce a dynamic linked library that can be used by other programming languages (and of course, also by Rust). The code compiled with this configuration will follow the C ABI (ordering, size, alignment of fields, etc…) enabling the possibility of directly linking the shared library with a C/C++ program or creating the bindings to use it in another language. The problem with this configuration and Rust is that using the shared object is not straightforward thanks to the C ABI. In another article I will explore this way and show how you can use a Rust library in other languages. ↩︎\nCompilations are quite fast because there’s not much code. It is enough to show the compilation times improvements. ↩︎\nYou may ask yourself why I used a feature flag and #[cfg_attr(feature = \"tests\", ...)] instead of plain #[cfg(test)]. With #[cfg(test)], only the current crate would be able to see things under that configuration, or in other words, we would not be able to use the things behind that configuration in the unit and integration tests of the binaries. ↩︎\nI am not sure why the codegen section (purple) disappeared from the graph and why it took almost the double to compile it. I made the modifications described here in some real world projects and the timings certainly did not doubled for the library crates. ↩︎\n","wordCount":"3161","inLanguage":"en","datePublished":"2024-10-02T12:00:00-03:00","dateModified":"2024-10-02T12:00:00-03:00","author":{"@type":"Person","name":"Nicolás Antinori"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://nicoan.github.io/posts/accelerating_compile_times/"},"publisher":{"@type":"Organization","name":"Nico Antinori","logo":{"@type":"ImageObject","url":"https://nicoan.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://nicoan.github.io/ accesskey=h title="Nico Antinori (Alt + H)">Nico Antinori</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://nicoan.github.io/ title=Home><span>Home</span></a></li><li><a href=https://nicoan.github.io/blog/ title=Blog><span>Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Accelerating Rust compilation times: Dynamic linking, code generation and cache</h1><div class=post-meta><span title='2024-10-02 12:00:00 -0300 -03'>October 2, 2024</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Nicolás Antinori</div></header><div class=post-content><p>Having a language that does a lot of checks at compile time is not free, it will impact compilation times. Luckily there are some things we can do to speed things up: Dynamic linking, be careful with code generation and caching dependencies.</p><p>Dynamic linking is a somewhat difficult thing to achieve in Rust but not impossible. The main reason is that at the time of writing this (Sept-Oct 2024) Rust does not have its own <a href=https://en.wikipedia.org/wiki/Application_binary_interface>stable ABI</a> and it must rely on the <a href=https://doc.rust-lang.org/nomicon/other-reprs.html#reprc>C binary representation</a> (if we want to inter-operate with other languages or <em>other Rust versions</em>). This has some interesting consequences that we will explore in this post.</p><p><a href=https://rustc-dev-guide.rust-lang.org/overview.html#code-generation>Code generation</a> is when the high level representation of the source code is turned into binary code that can be executed by the machine. Given that the rust compiler uses <a href=https://llvm.org/>LLVM</a>, the level of optimizations and the quantity of generated code will affect the compilation speed.</p><h1 id=what-is-linking>What is Linking?<a hidden class=anchor aria-hidden=true href=#what-is-linking>#</a></h1><p>Programs are usually divided into several modules and they have numerous dependencies. Linking is a compilation stage where all the compiled code of those modules needed by a program (and the code of the program itself) is made available in the final executable. We have two ways of linking a program: static and dynamic.</p><h2 id=static-linking>Static Linking<a hidden class=anchor aria-hidden=true href=#static-linking>#</a></h2><p>All the code needed by a program (from external modules and the program itself) is put together in the final executable. This creates fat binaries but it makes the program portable.</p><h2 id=dynamic-linking>Dynamic Linking<a hidden class=anchor aria-hidden=true href=#dynamic-linking>#</a></h2><p>This type of linking must be supported by the operating system (most, if not all of the major operating systems support this). In this approach, instead of containing all the code needed, the executable contains undefined symbols and a list of objects that contain the code for those symbols.</p><p>These objects, often referred to as libraries, are binary files used to share binary code between several programs. In Microsoft Windows those files are known as DLLs (dynamically-linked library) and in Unix operating systems (Linux, Mac OS, etc) are known as SOs (shred objects).</p><p>When running a dynamically linked executable, the operating system loads the program code along with the libraries in memory and do the final linking.</p><p>This approach creates “thin” binaries and saves disk and memory space, since the code from the libraries are shared among several applications.</p><h2 id=different-linking-modes-in-rust>Different linking modes in Rust<a hidden class=anchor aria-hidden=true href=#different-linking-modes-in-rust>#</a></h2><p>There are several different linking modes that we can use, producing different kind of shared objects, but in this post we will focus only on one of them: <code>dylib</code>.</p><p>If we put this configuration in our <em>library</em> crates, the Rust compiler will generate a dynamic library that will be dynamically linked with our executable. Isn’t that what we need? Why do we have other configurations?<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> Given that Rust does not have an stable ABI yet, there are no guarantees that the compiled libraries will work if we don’t compile the project with the same Rust version used for compiling the library.</p><p>This mode is suitable for a project where we have one or more library crates that are used by several binary crates (or other libraries). We will usually compile everything altogether the first time and then recompile only the things we change. If we change the Rust version, we need to recompile everything.</p><h1 id=compilation-stages>Compilation stages<a hidden class=anchor aria-hidden=true href=#compilation-stages>#</a></h1><p>To generate binary objects, Rust compiler must go through <a href=https://rustc-dev-guide.rust-lang.org/overview.html#what-the-compiler-does-to-your-code>several different stages</a>. I am not going to explain how a compiler works in detail, but having a general idea of what happens will help us identify places where we can work to optimize compile times.</p><p>To measure compilation times, we will use the built-in cargo tool called <a href=https://doc.rust-lang.org/cargo/reference/timings.html><em>timings</em></a>. This tool will generate a detailed HTML report showing how long every compilation unit takes to compile.</p><h2 id=from-source-code-to-intermediate-representation>From source code to intermediate representation<a hidden class=anchor aria-hidden=true href=#from-source-code-to-intermediate-representation>#</a></h2><p>In the timings report, the stages described below are pictured in light blue in the Grantt chart.</p><h3 id=lexing-and-parsing>Lexing and parsing<a hidden class=anchor aria-hidden=true href=#lexing-and-parsing>#</a></h3><p>The compiler first performs the <a href=https://rustc-dev-guide.rust-lang.org/overview.html#lexing-and-parsing>lexing and parsing stage</a>, where lexing is transforming the source code into an stream of tokens and parsing is generating an <a href=https://en.wikipedia.org/wiki/Abstract_syntax_tree>AST (Abstract Syntax Tree)</a> from those tokens.</p><p><a href=https://rustc-dev-guide.rust-lang.org/macro-expansion.html>Macro expansion</a> (generating valid Rust code from the macros) is also done at this stage.</p><h3 id=ast-lowering>AST Lowering<a hidden class=anchor aria-hidden=true href=#ast-lowering>#</a></h3><p>After the AST is created, it is converted into a High Level Intermediate Representation (HIR), this stage is called <a href=https://rustc-dev-guide.rust-lang.org/overview.html#ast-lowering>AST Lowering</a>. In HIR the compiler does type inference, type checking and resolve traits.</p><h3 id=mir-lowering>MIR Lowering<a hidden class=anchor aria-hidden=true href=#mir-lowering>#</a></h3><p>When HIR is ready, then we enter the <a href=https://rustc-dev-guide.rust-lang.org/overview.html#mir-lowering>MIR lowering stage</a>, that is, transforming HIR to Middle Level Representation (MIR). In this stage, the famous borrow checking is done, <a href=https://en.wikipedia.org/wiki/Monomorphization>code monomorphization</a>, and some optimizations that will improve code generation and compilation speed in that stage.</p><h2 id=code-generation>Code generation<a hidden class=anchor aria-hidden=true href=#code-generation>#</a></h2><p>This stage is pictured in purple in the Grantt chart. When we are here, the compiler already has everything represented in MIR. During this phase, the MIR is transformed into LLVM-IR (LLVM Intermediate Representation) and handled to LLVM.</p><p>LLVM does a lot more of optimizations and generates the assembler and binary code that later is linked into the final object.</p><p>If you want to learn more about the compilation stages, check <a href=https://rustc-dev-guide.rust-lang.org/overview.html>this article</a>.</p><h1 id=reducing-compile-times>Reducing compile times<a hidden class=anchor aria-hidden=true href=#reducing-compile-times>#</a></h1><h2 id=the-toy-project>The toy project<a hidden class=anchor aria-hidden=true href=#the-toy-project>#</a></h2><p>In order to show how to optimize compiling times, we are going to use a toy project that consist in one library crate and 40 separate binaries that use the library. You may ask yourself: What kind of project has that structure?! It could be a server-less project containing several cloud functions (like AWS Lambdas) that share functionality through some library crates or some project that consist in several binaries (like <a href=https://es.wikipedia.org/wiki/GNU_Core_Utilities>GNU Core utilities</a>).</p><h2 id=how-i-get-the-timings>How I get the timings<a hidden class=anchor aria-hidden=true href=#how-i-get-the-timings>#</a></h2><p>The timings found on this posts are the last timing returned by cargo after running 10 times the same compilation, always doing <code>cargo clean</code> before executing <code>cargo build [...]</code>. I compile the project 10 times to verify that <em>on average</em> the compilation times are more or less the same.</p><h2 id=initial-compile-times>Initial compile times<a hidden class=anchor aria-hidden=true href=#initial-compile-times>#</a></h2><p>Here are the individual compile times for the toy project. This and further compilations were done in Debian 12, with an i7-6700K and 16GB DDR4 2600Mhz Ram <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>:</p><p><img loading=lazy src=/images/accelerating_compile_times/1.png#center alt=image.png></p><p>The total time was</p><pre tabindex=0><code>Finished `release` profile [optimized] target(s) in 25.30s
</code></pre><p>And the size of the binaries is about 3.5MB:</p><pre tabindex=0><code>ls -l --block-size=KB ./target/release
total 143262kB
-rwxr-xr-x  2 nico nico 3489kB Sep 16 15:03 bin1
-rwxr-xr-x  2 nico nico 3489kB Sep 16 15:03 bin10
-rw-r--r--  1 nico nico    1kB Sep 16 15:04 bin10.d
-rwxr-xr-x  2 nico nico 3489kB Sep 16 15:03 bin11
-rw-r--r--  1 nico nico    1kB Sep 16 15:04 bin11.d
-rwxr-xr-x  2 nico nico 3489kB Sep 16 15:03 bin12
-rw-r--r--  1 nico nico    1kB Sep 16 15:04 bin12.d
-rwxr-xr-x  2 nico nico 3489kB Sep 16 15:03 bin13
</code></pre><p>The command used was <code>cargo build --release --timings</code>. You can check the source code of the toy project <a href=https://github.com/nicoan/compile_times_blogpost/tree/initial-stage>here</a>.</p><h2 id=removing-unnecessary-dependencies>Removing unnecessary dependencies<a hidden class=anchor aria-hidden=true href=#removing-unnecessary-dependencies>#</a></h2><p>It is common that in a project, the people involved usually forget about removing old dependencies. This happens because when projects are large, it is hard to know if a dependency is not used anymore. Luckily, we can use the <code>-Wunused-crate-dependencies</code> flag that tells us which dependencies are not being used by the crates inside the project. If we compile with <code>RUSTFLAGS=-Wunused-crate-dependencies cargo build --release --timings</code> we get the following output:</p><pre tabindex=0><code>...
warning: external crate `actix` unused in `lib1`: remove the dependency or add `use actix as _;`
  |
  = note: requested on the command line with `-W unused-crate-dependencies`

warning: external crate `serde_json` unused in `lib1`: remove the dependency or add `use serde_json as _;`

warning: external crate `tokio` unused in `lib1`: remove the dependency or add `use tokio as _;`

warning: `lib1` (lib) generated 3 warnings
</code></pre><p>By removing the unused dependencies reported by the warnings, we reduced the <em>total</em> compilation time a little:</p><pre tabindex=0><code>Finished `release` profile [optimized] target(s) in 23.85s
</code></pre><p>It is not much, but by not compiling those dependencies, we gained around 1.x seconds! To keep our project clean, we can use this flag in our CI/CD pipeline to warn us when we forget to remove an old dependency.</p><p>You can find the modifications made in this section <a href=https://github.com/nicoan/compile_times_blogpost/tree/1-rm-unused-deps>here</a>.</p><h2 id=removing-unnecessary-derives>Removing unnecessary derives<a hidden class=anchor aria-hidden=true href=#removing-unnecessary-derives>#</a></h2><p>Macros create valid Rust code that then has to be parsed, transformed, validated and optimized. It may happen that you need to derive some trait, not because is used by productive code but is used by test code. It does not make sense to process that code in release builds.</p><p>A nice “trick” to avoid processing that code in release builds is to derive it behind a <a href=https://doc.rust-lang.org/cargo/reference/features.html>cargo feature</a> and only activate that feature in the <code>[dev-dependencies]</code> section of the <code>Cargo.toml</code>. The <code>Cargo.toml</code> from <code>lib1</code> was changed this way:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>[<span style=color:#a6e22e>package</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>name</span> = <span style=color:#e6db74>&#34;lib1&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>version</span> = <span style=color:#e6db74>&#34;0.1.0&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>edition</span> = <span style=color:#e6db74>&#34;2021&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>dependencies</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>mockall</span> = { <span style=color:#a6e22e>workspace</span> = <span style=color:#66d9ef>true</span>, <span style=color:#a6e22e>optional</span> = <span style=color:#66d9ef>true</span> }
</span></span><span style=display:flex><span><span style=color:#a6e22e>reqwest</span> = { <span style=color:#a6e22e>workspace</span> = <span style=color:#66d9ef>true</span> }
</span></span><span style=display:flex><span><span style=color:#a6e22e>serde</span> =  { <span style=color:#a6e22e>workspace</span> = <span style=color:#66d9ef>true</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>features</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>tests</span> = [<span style=color:#e6db74>&#34;dep:mockall&#34;</span>]
</span></span></code></pre></div><p>And we put behind the <code>tests</code> feature, all the code we do not need in production <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[cfg_attr(feature = </span><span style=color:#e6db74>&#34;tests&#34;</span><span style=color:#75715e>, mockall::automock)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>trait</span> Trait1 {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fn1</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fn2</span>(a: <span style=color:#66d9ef>u16</span>) -&gt; String;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fn3</span>(a: String) -&gt; <span style=color:#66d9ef>u16</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Serialize, Default)]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[cfg_attr(feature = </span><span style=color:#e6db74>&#34;tests&#34;</span><span style=color:#75715e>, derive(Deserialize, PartialEq, Eq, Debug))]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Struct1</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> f1: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> f2: String,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> f3: <span style=color:#a6e22e>HashMap</span><span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> f4: <span style=color:#a6e22e>HashSet</span><span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> f5: Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Deserialize, Default)]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[cfg_attr(feature = </span><span style=color:#e6db74>&#34;tests&#34;</span><span style=color:#75715e>, derive(Serialize, PartialEq, Eq, Debug))]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Struct9</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> f1: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> f2: String,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> f3: <span style=color:#a6e22e>HashMap</span><span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> f4: <span style=color:#a6e22e>HashSet</span><span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> f5: Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Activating the feature will work for both unit and integration tests. Here are the compilation times after introducing the flag:</p><p><img loading=lazy src=/images/accelerating_compile_times/2.png#center alt=image.png></p><p>And the total time:</p><pre tabindex=0><code>Finished release profile [optimized] target(s) in 21.58s
</code></pre><p>By reducing the code generated by the derives and <code>automock</code> macros, Rust have less code to translate to intermediate representation (light blue), code to generate (purple) and optimize. The time reduction was <strong>huge</strong>, from an average of 4.x seconds to an average of 0.3 seconds.</p><p>The take-home lesson here is: do not take the auto generation of code. If you don’t need it in the production build, do not compile it.</p><p>You can find the modifications made in this section <a href=https://github.com/nicoan/compile_times_blogpost/tree/2-rm-unused-derives>here</a>.</p><h2 id=dynamic-linking-1>Dynamic Linking<a hidden class=anchor aria-hidden=true href=#dynamic-linking-1>#</a></h2><p>Until now, the code contained in <code>lib1</code> is statically linked to all the binaries in our project. Instead of repeating the code in every binary, we can use dynamic linking to have <code>lib1</code> as a shared object, allowing the binaries to use the code without the need of having it embedded.</p><p>With dynamic linking we will not only achieve faster compile times, we will also get smaller binaries and, if there’s a bug in the library, we can fix it and deploy the shared object without the need of modifying the binaries (as long as we use the same Rust version used to compile the binaries).</p><p>To activate dynamic linking, we need to add to the <code>lib1</code>&rsquo;s <code>Cargo.toml</code> the following lines at the end:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>[<span style=color:#a6e22e>lib</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>crate-type</span> = [<span style=color:#e6db74>&#34;dylib&#34;</span>]
</span></span></code></pre></div><p>And compile ithe project t with: <code>RUSTFLAGS="-C prefer-dynamic" cargo build --release --timings</code>. Here are the compilation times with dynamic linking:</p><p><img loading=lazy src=/images/accelerating_compile_times/3.png#center alt=image.png></p><p>The compilation times for <code>lib1</code> increased <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>, but for binaries times reduced from an average of 0.8x to an average of 0.3x! They were also reduced in size: from 3489 kB to 12 kB!</p><pre tabindex=0><code>ls -l --block-size=KB ./target/release
total 7238kB
-rwxr-xr-x  2 nico nico   12kB Sep 16 14:43 bin1
-rwxr-xr-x  2 nico nico   12kB Sep 16 14:43 bin10
-rw-r--r--  1 nico nico    1kB Sep 16 14:43 bin10.d
-rwxr-xr-x  2 nico nico   12kB Sep 16 14:43 bin11
-rw-r--r--  1 nico nico    1kB Sep 16 14:43 bin11.d
-rwxr-xr-x  2 nico nico   12kB Sep 16 14:43 bin12
...
drwxr-xr-x  2 nico nico    5kB Sep 16 14:43 incremental
-rw-r--r--  1 nico nico    1kB Sep 16 14:43 liblib1.d
-rwxr-xr-x  2 nico nico 6555kB Sep 16 14:43 liblib1.so
</code></pre><p>The total time was</p><pre tabindex=0><code>Finished `release` profile [optimized] target(s) in 19.74s
</code></pre><p>If we check the libraries needed for any of our binaries, we are going to see a dependency with <code>liblib1.so</code>. <code>ldd</code> outputs &ldquo;not found&rdquo; because the shared object is located in the target directory at the moment of running the command and not in the usual paths where shared objects can be found (<code>/lib</code>, <code>/usr/lib</code> , <code>/usr/local/lib</code>) or in any of the paths listed in the <code>LD_LIBRARY_PATH</code> environment variable.</p><pre tabindex=0><code>$ ldd ./target/release/bin1
        linux-vdso.so.1 (0x00007ffe573aa000)
        liblib1.so =&gt; not found
        libstd-52417a9a08ba8fb9.so =&gt; not found
        libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007fc19594a000)
        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fc195769000)
        /lib64/ld-linux-x86-64.so.2 (0x00007fc195986000)
</code></pre><p>You can find the modifications made in this section <a href=https://github.com/nicoan/compile_times_blogpost/tree/3-dynamic-linking>here</a>.</p><h2 id=cache-dependencies>Cache dependencies<a hidden class=anchor aria-hidden=true href=#cache-dependencies>#</a></h2><p>Most of the total compilation time was taken by the the project&rsquo;s dependencies. In this section we are going to explore two ways those dependencies can be cached so we avoid recompiling them every time we build it. This is specially useful in a continuous integration/deployment environment, where we are constantly compiling the project but the dependencies rarely change.</p><h3 id=sccache>sccache<a hidden class=anchor aria-hidden=true href=#sccache>#</a></h3><p><a href=https://github.com/mozilla/sccache>sccache</a> is a tool developed by Mozilla. It can be used with several compilers, not only rustc. It works as a wrapper of the compiler, chaching compiled things locally on disk and avoiding recompiling them if possible.</p><p>To install it, we can run:</p><pre tabindex=0><code>$ cargo install sccache
</code></pre><p>Then, we can use it by wrapping the <code>rustc</code> compiler with the <code>RUSTC_WRAPPER</code> environment variable:</p><pre tabindex=0><code>$ RUSTC_WRAPPER=sccache RUSTFLAGS=&#34;-C prefer-dynamic&#34; cargo build --release --timings
</code></pre><p>We compiled the project with the dynamic linking activated. The first compilation took around 23 seconds, 3.x seconds more than last compilation but, in the first one, <code>sccache</code> was caching the compiled dependencies. After running <code>cargo clean</code> and recompiling the project again we get:</p><pre tabindex=0><code>Finished `release` profile [optimized] target(s) in 6.54s
</code></pre><p>So, we dropped from an average of 19.x seconds to an average of 6.5x seconds!</p><h3 id=cargo-chef>Cargo Chef<a hidden class=anchor aria-hidden=true href=#cargo-chef>#</a></h3><p><a href=https://crates.io/crates/cargo-chef/>cargo-chef</a> is an awesome tool created by <a href=https://www.lpalmieri.com/>Luca Palmieri</a>. It is designed to speed up compilation times when using containers to build the project. Basically, what it does under the hood is locate all the entry points of our workspace either for libs (<code>lib.rs</code>) or binaries (<code>main.rs</code>), remove all the code from them, leave some trivial code like</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// main.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {}
</span></span></code></pre></div><p>and compile the project. In other words, it avoids compiling the source code from the project. It just compiles the dependencies to cache them. In future compilations, the dependencies will be already cached, so only the project’s business logic will be compiled.</p><p><a href=https://crates.io/crates/cargo-chef/0.1.68#user-content-how-to-use>As stated in the official documentation</a> and in a warning if you try to use it locally, this is designed to be used with containers because it leverages on the Docker&rsquo;s layer cache mechanism to work. <strong>It is not recommended</strong> using it to compile the project locally.</p><p>For demonstration purposes, I modified the Dockerfile suggested in the official cargo chef documentation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> lukemathwalker/cargo-chef:latest-rust-1 AS chef</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> chef AS planner</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> . .<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> cargo chef prepare --recipe-path recipe.json<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> chef AS builder</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> --from<span style=color:#f92672>=</span>planner /app/recipe.json recipe.json<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Build dependencies - this is the caching Docker layer!</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> CARGO_TARGET_DIR<span style=color:#f92672>=</span>/app/cache RUSTFLAGS<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;-C prefer-dynamic&#34;</span> cargo chef cook --release --workspace --recipe-path recipe.json<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> . .<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENTRYPOINT</span> [<span style=color:#e6db74>&#34;/bin/sh&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>The image produced from this Dockerfile will contain all the project dependencies already cached in <code>/app/cache</code> directory. It is <strong>very important</strong> to use cargo chef with exactly the same configuration you are going to use to compile the project. Since we are using the dynamic linking branch for the demonstration, we must include the <code>RUSTFLAGS="-C prefer-dynamic"</code> flag.</p><p>Here are the steps I followed:</p><ol><li>Build the image: <code>docker build --tag chef .</code></li><li>Enter the container: <code>docker run -it chef</code></li><li>Compile the project: <code>CARGO_TARGET_DIR=/app/cache RUSTFLAGS="-C prefer-dynamic" cargo build --release --workspace</code>.</li></ol><p>The total compilation time is:</p><pre tabindex=0><code>Finished `release` profile [optimized] target(s) in 2.64s
</code></pre><p>We’ve just compiled the <em>whole project</em> in 2.64s! This is a massive time reduction!</p><h1 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h1><p>We started our compile time reduction journey with static linked binaries with a size of 3489kB and a total compilation time of 25.x seconds and we finished it with dynamically linked binaries with a size of 12kB and a total compilation time of 2.x seconds:</p><table><thead><tr><th>Modification</th><th>Total time</th><th>% Time reduction from original</th></tr></thead><tbody><tr><td>Original codebase</td><td>25.3s</td><td>0%</td></tr><tr><td>Remove unused dependencies</td><td>23.85s</td><td>5.73%</td></tr><tr><td>Remove unnecesary derives</td><td>21.58s</td><td>14.70%</td></tr><tr><td>Dynamic Linking</td><td>19.74s</td><td>21.98%</td></tr><tr><td>Dynamic Linking + sccache</td><td>6.54s</td><td>75.15%</td></tr><tr><td>Dynamic Linking + cargo chef</td><td>2.64s</td><td>89.57%</td></tr></tbody></table><p>It is important to remember that all the steps include the modifications from the previous steps, with the exception of the caches, that use the dynamic linking branch but sccache and cargo chef are used separately.</p><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>Sometimes when we are working on projects, deadlines are tight, product team need to release new features and we need to choose wisely on what we spend our time. If we are lucky enough to be in a team that saves time to work on technical debt, we should really use that oportunity to make the structural changes needed in the project to reduce the compilation times. This may sound obvious but not everyone agrees on what is important to solve first.</p><p>When projects are small, compilation times are usually small or tolerable, so we don’t pay much attention. As it grows, compilation times may become a real bottleneck for development (imagine that deploying a new version to a <code>dev</code> environment takes an hour).</p><p>Taking care of the compilation will save the whole team a lot of time and headaches, enabling everyone to develop, test and deploy faster.</p><h1 id=resources>Resources<a hidden class=anchor aria-hidden=true href=#resources>#</a></h1><ul><li><a href=https://zicklag.github.io/rust-tutorials/rust-plugins.html>Learn how to setup dynamically loadable plugins for your Rust app</a></li><li><a href=https://doc.rust-lang.org/reference/linkage.html>Rust’s official Linkage page</a></li><li><a href=https://blog.pnkfx.org/blog/2022/05/12/linking-rust-crates/>Linking Rust crates series</a></li><li><a href=https://nnethercote.github.io/perf-book/build-configuration.html#minimizing-compile-times>Minimizing Compile Times</a></li><li><a href=https://robert.kra.hn/posts/2022-09-09-speeding-up-incremental-rust-compilation-with-dylibs/>Speeding up incremental Rust compilation with dylibs</a></li><li><a href=https://doc.rust-lang.org/cargo/guide/build-cache.html>Build cache</a></li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>There’s a mode that we can use to avoid recompiling the library to match the Rust version we are currently using: <code>cdylib</code> . This mode will produce a dynamic linked library that can be used by other programming languages (and of course, also by Rust). The code compiled with this configuration will follow the C ABI (ordering, size, alignment of fields, etc…) enabling the possibility of directly linking the shared library with a C/C++ program or creating the bindings to use it in another language. The problem with this configuration and Rust is that using the shared object is not straightforward thanks to the C ABI. In another article I will explore this way and show how you can use a Rust library in other languages.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Compilations are quite fast because there&rsquo;s not much code. It is enough to show the compilation times improvements.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>You may ask yourself why I used a feature flag and <code>#[cfg_attr(feature = "tests", ...)]</code> instead of plain <code>#[cfg(test)]</code>. With <code>#[cfg(test)]</code>, only the current crate would be able to see things under that configuration, or in other words, we would not be able to use the things behind that configuration in the unit and integration tests of the binaries.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>I am not sure why the codegen section (purple) disappeared from the graph and why it took almost the double to compile it. I made the modifications described here in some real world projects and the timings certainly did not doubled for the library crates.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Accelerating Rust compilation times: Dynamic linking, code generation and cache on x" href="https://x.com/intent/tweet/?text=Accelerating%20Rust%20compilation%20times%3a%20Dynamic%20linking%2c%20code%20generation%20and%20cache&amp;url=https%3a%2f%2fnicoan.github.io%2fposts%2faccelerating_compile_times%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Accelerating Rust compilation times: Dynamic linking, code generation and cache on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fnicoan.github.io%2fposts%2faccelerating_compile_times%2f&amp;title=Accelerating%20Rust%20compilation%20times%3a%20Dynamic%20linking%2c%20code%20generation%20and%20cache&amp;summary=Accelerating%20Rust%20compilation%20times%3a%20Dynamic%20linking%2c%20code%20generation%20and%20cache&amp;source=https%3a%2f%2fnicoan.github.io%2fposts%2faccelerating_compile_times%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Accelerating Rust compilation times: Dynamic linking, code generation and cache on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fnicoan.github.io%2fposts%2faccelerating_compile_times%2f&title=Accelerating%20Rust%20compilation%20times%3a%20Dynamic%20linking%2c%20code%20generation%20and%20cache"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Accelerating Rust compilation times: Dynamic linking, code generation and cache on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fnicoan.github.io%2fposts%2faccelerating_compile_times%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Accelerating Rust compilation times: Dynamic linking, code generation and cache on whatsapp" href="https://api.whatsapp.com/send?text=Accelerating%20Rust%20compilation%20times%3a%20Dynamic%20linking%2c%20code%20generation%20and%20cache%20-%20https%3a%2f%2fnicoan.github.io%2fposts%2faccelerating_compile_times%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Accelerating Rust compilation times: Dynamic linking, code generation and cache on telegram" href="https://telegram.me/share/url?text=Accelerating%20Rust%20compilation%20times%3a%20Dynamic%20linking%2c%20code%20generation%20and%20cache&amp;url=https%3a%2f%2fnicoan.github.io%2fposts%2faccelerating_compile_times%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Accelerating Rust compilation times: Dynamic linking, code generation and cache on ycombinator" href="https://news.ycombinator.com/submitlink?t=Accelerating%20Rust%20compilation%20times%3a%20Dynamic%20linking%2c%20code%20generation%20and%20cache&u=https%3a%2f%2fnicoan.github.io%2fposts%2faccelerating_compile_times%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://nicoan.github.io/>Nico Antinori</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>