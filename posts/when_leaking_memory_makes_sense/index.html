<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>When leaking memory makes sense: Leaking memory in Rust | Nico Antinori</title>
<meta name=keywords content="rust,low-level,heap,leak"><meta name=description content="It is believed that it is impossible to leak memory with Rust, that is not true. Although is way more difficult to leak memory in Rust than in other languages, it can happen, sometimes by accident, and sometimes, by design. In this article we will explore some cases where leaking memory is useful.
Sharing memory between threads
Imagine that you have a value that it does not change and needs to be shared across several threads. If the value can be initialized with constant functions or values, you can use the static keyword. But what if the value to be shared is not constant? What are the options?"><meta name=author content="Nicolás Antinori"><link rel=canonical href=https://nicoan.net/posts/when_leaking_memory_makes_sense/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://nicoan.net/assets/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nicoan.net/assets/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://nicoan.net/assets/favicon-32x32.png><link rel=apple-touch-icon href=https://nicoan.net/assets/apple-touch-icon.png><link rel=mask-icon href=https://nicoan.net/assets/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="When leaking memory makes sense: Leaking memory in Rust"><meta property="og:description" content="It is believed that it is impossible to leak memory with Rust, that is not true. Although is way more difficult to leak memory in Rust than in other languages, it can happen, sometimes by accident, and sometimes, by design. In this article we will explore some cases where leaking memory is useful.
Sharing memory between threads
Imagine that you have a value that it does not change and needs to be shared across several threads. If the value can be initialized with constant functions or values, you can use the static keyword. But what if the value to be shared is not constant? What are the options?"><meta property="og:type" content="article"><meta property="og:url" content="https://nicoan.net/posts/when_leaking_memory_makes_sense/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-01T12:00:00-03:00"><meta property="article:modified_time" content="2025-04-01T12:00:00-03:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="When leaking memory makes sense: Leaking memory in Rust"><meta name=twitter:description content="It is believed that it is impossible to leak memory with Rust, that is not true. Although is way more difficult to leak memory in Rust than in other languages, it can happen, sometimes by accident, and sometimes, by design. In this article we will explore some cases where leaking memory is useful.
Sharing memory between threads
Imagine that you have a value that it does not change and needs to be shared across several threads. If the value can be initialized with constant functions or values, you can use the static keyword. But what if the value to be shared is not constant? What are the options?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://nicoan.net/posts/"},{"@type":"ListItem","position":2,"name":"When leaking memory makes sense: Leaking memory in Rust","item":"https://nicoan.net/posts/when_leaking_memory_makes_sense/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"When leaking memory makes sense: Leaking memory in Rust","name":"When leaking memory makes sense: Leaking memory in Rust","description":"It is believed that it is impossible to leak memory with Rust, that is not true. Although is way more difficult to leak memory in Rust than in other languages, it can happen, sometimes by accident, and sometimes, by design. In this article we will explore some cases where leaking memory is useful.\nSharing memory between threads Imagine that you have a value that it does not change and needs to be shared across several threads. If the value can be initialized with constant functions or values, you can use the static keyword. But what if the value to be shared is not constant? What are the options?\n","keywords":["rust","low-level","heap","leak"],"articleBody":"It is believed that it is impossible to leak memory with Rust, that is not true. Although is way more difficult to leak memory in Rust than in other languages, it can happen, sometimes by accident, and sometimes, by design. In this article we will explore some cases where leaking memory is useful.\nSharing memory between threads Imagine that you have a value that it does not change and needs to be shared across several threads. If the value can be initialized with constant functions or values, you can use the static keyword. But what if the value to be shared is not constant? What are the options?\nUsing Arc Arc is a smart pointer that allow us to share a value safely between threads. ”Arc” stands for “Atomically Reference Counted”. The value owned by the Arc can be read from different threads. Every time an Arc is cloned, the internal counter is incremented by one, and every time an Arc is dropped, the internal counter is decremented by one. Once the counter goes from 1 to 0, the resource owned by the Arc is cleaned up. For example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 use std::env; use std::sync::Arc; use std::thread; fn main() { let name: String = env::args().collect::\u003cVec\u003cString\u003e\u003e().remove(1); let person_name: Arc\u003cString\u003e = Arc::new(name); let p = person_name.clone(); let t1 = thread::spawn(move || { println!(\"Hello {p}\"); }); let p = person_name.clone(); let t2 = thread::spawn(move || { println!(\"Bye {p}\"); }); let _ = t1.join(); let _ = t2.join(); } This program receives a name by argument and spawns two threads that read that value. In this example there is no leak: Once the threads finish executing, the Arc is dropped and when the main thread exits, the value is cleaned up, since the Arc owned by the main function is the last reference to the name.\nLeaking memory with Box::leak Instead of creating an Arc and moving the clones where we need, we can leak the memory with Box::leak and shared it with the threads:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 use std::env; use std::thread; fn main() { let name: String = env::args().collect::\u003cVec\u003cString\u003e\u003e().remove(1); let person_name: \u0026'static String = Box::leak(Box::new(name)); let t1 = thread::spawn(move || { println!(\"Hello {person_name}\"); }); let t2 = thread::spawn(move || { println!(\"Bye {person_name}\"); }); let _ = t1.join(); let _ = t2.join(); } In line 6, we are leaking the memory creating an static reference and then we are moving it to the spawned threads so they can be read by them1.\nThe code showed above is just an example, an actual useful case for leaking memory and reading it from threads or async tasks is having a global configuration loaded at runtime that we know it won’t change for the entire execution of the program.\nIf we check this code with valgrind\nvalgrind ./target/release/box_leak John ==691== Memcheck, a memory error detector ==691== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==691== Using Valgrind-3.16.1 and LibVEX; rerun with -h for copyright info ==691== Command: ./target/release/box_leak John ==691== Bye John Hello John ==691== ==691== HEAP SUMMARY: ==691== in use at exit: 28 bytes in 2 blocks ==691== total heap usage: 27 allocs, 25 frees, 4,229 bytes allocated ==691== ==691== LEAK SUMMARY: ==691== definitely lost: 24 bytes in 1 blocks ==691== indirectly lost: 4 bytes in 1 blocks ==691== possibly lost: 0 bytes in 0 blocks ==691== still reachable: 0 bytes in 0 blocks ==691== suppressed: 0 bytes in 0 blocks ==691== Rerun with --leak-check=full to see details of leaked memory ==691== ==691== For lists of detected and suppressed errors, rerun with: -s ==691== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) We effectively see that not all memory was freed.\nForeign Function Interfaces (FFI) Libraries created in Rust can be used in other languages (commonly C) through Foreign Function Interfaces. In other languages, the way of doing things are usually different than in Rust. For example, in C, exists the “Opaque Pointer Pattern”. The objetive of this pattern is to hide implementations details by using an opaque pointer. To implement this pattern we need a function to create a struct which details are hidden, functions to operate on the struct and a function to destroy it.\nSuppose you want to reimplement a stack data structure, originally written in C, using Rust. Here’s the header file:\n#ifndef STACK_H #define STACK_H #include // This is the opaque type typedef struct Stack Stack; Stack *stack_create(int capacity); void stack_destroy(Stack *stack); bool stack_push(Stack *stack, int value); bool stack_pop(Stack *stack, int *out); bool stack_peek(const Stack *stack, int *out); bool stack_is_empty(const Stack *stack); #endif Data representation To re-implement the stack library, we need to represent the stack in Rust and follow the interface from the header file. For this implementation, we’ll use a Vec structure:\ntype Stack = Vec\u003ci32\u003e; Allocating memory and leaking it Following the interface defined by the header file, we need to create a function that takes the capacity of the Stack and returns a pointer to it. This means that we need to allocate in memory some kind of data that represents a Stack structure (in this case a Vec) and return a pointer to it. This is implemented as follows:\n#[unsafe(no_mangle)] pub extern \"C\" fn stack_create(capacity: usize) -\u003e *mut Stack { Box::into_raw(Box::new(Vec::with_capacity(capacity))) } What we do in this function is create the Vec with the capacity passed by argument, save it inside a Box and use Box::into_raw to consume the Box and return a raw pointer to the vector. This means that the vector is allocated in memory and is accesible by our program, but now it is our responsibility to be sure that the pointer is allocated with the Stack representation when we want to use it and to release the memory when we do not need it anymore.\nThis is analogous to using malloc to allocate memory for the data structure and initialize it with values in C.\nReclaiming the leaked memory to release it If we do not free the Stack allocated by the function stack_create, we will indeed have created a memory leak. The header file declares a function to destroy it, here’s the implementation in Rust:\n#[unsafe(no_mangle)] pub unsafe extern \"C\" fn stack_destroy(stack: *mut Stack) { if !stack.is_null() { let _ = unsafe { Box::from_raw(stack) }; } } Here, if the stack pointer is not null, we reconstruct the Box to reclaim the ownership of the allocated memory. The created Box is immediately dropped, releasing the memory.\nIf we compile the main.c program and verify it with valgrind, we see that there’s no leak\n$ valgrind ./main ==580== Memcheck, a memory error detector ==580== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==580== Using Valgrind-3.16.1 and LibVEX; rerun with -h for copyright info ==580== Command: ./main ==580== Top of stack: 20 Popped: 20 Popped: 10 ==580== ==580== HEAP SUMMARY: ==580== in use at exit: 0 bytes in 0 blocks ==580== total heap usage: 3 allocs, 3 frees, 1,056 bytes allocated ==580== ==580== All heap blocks were freed -- no leaks are possible ==580== ==580== For lists of detected and suppressed errors, rerun with: -s ==580== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) We can see that there are no leaks! So, technically we did not leaked memory, it was just a temporal thing from the Rust perspective, and, from C’s perspective, we were simply allocating memory and freeing it correctly afterward.\nYou can find the full implementation of both C and Rust here.\nCan Box::leak be used instead of Box::into_raw? Yes, but in my opinion you should not. Semantically, using Box::from_raw to re-create a Box from a Box::leak is incorrect because, technically, you did not intend to leak memory if you reclaim it with the objetive of releasing it. Check out the following code:\nfn reconstruct_and_drop(value: \u0026mut i32) { let _ = unsafe { Box::from_raw(value as *mut i32) }; } fn main() { let value = Box::new(42); let static_value: \u0026'static mut i32 = Box::leak(value); println!(\"The value is {}\", static_value); reconstruct_and_drop(static_value); println!(\"The value is {}\", static_value); } This results in the following output:\nThe value is 42 The value is 431898688 Here, we leak the value 42, and we give it a 'static lifetime. Citing the Rust Book:\nBut before specifying 'static as the lifetime for a reference, think about whether the reference you have actually lives the entire lifetime of your program or not, and whether you want it to\nAdditionally, by definition, a reference is valid throughout its entire lifetime, unlike a raw pointer.\nUnlike a pointer, a reference is guaranteed to point to a valid value of a particular type for the life of that reference.\nAnd Box::leak returns a reference that, as showed in the example above, we can invalidate. The example is very simple and the error can be spotted right away, but in a larger codebase, this could become a bug hard to find and fix.\nIn situations where we need a raw pointer and know we’ll going to reclaim the memory to release it is semantically correct to use the Box::into_raw / Box::from_raw pair of functions.\nConclusion Even though leaking memory can be an useful resource, it must be used with care. We can’t abuse this mechanism because we can create unintended problems, like running out of memory, or consuming too much of it without an specific purpose.\nBut, why re-implement things in Rust and use these tricks? This would require a whole article to explain, but the short answer is that even though you need to use unsafe keyword from time to time, if used correctly, you still have a lot of compile-time checks and safety guarantees that Rust provides out of the box.\nLastly, a real-word scenario where this technique is used is the Redox OS’s libc re-implementation un Rust called relibc (for example, in the regcomp function here’s the Box::into_raw, and in the regfree function here’s the Box::from_raw)\nReferences https://marabos.nl/atomics/basics.html#shared-ownership-and-reference-counting You may wonder why we need to use the move keyword if we are creating an ’static reference. Remember that closures capture their environment by reference, so what we are really capturing here is a \u0026\u0026'static String and not a \u0026'static String where the outer reference is not 'static. When using move, we are “moving” \u0026'static String into the thread, but, since they are references and references are Copy, we just copy the reference inside of the thread, not destroying it outside. ↩︎\n","wordCount":"1767","inLanguage":"en","datePublished":"2025-04-01T12:00:00-03:00","dateModified":"2025-04-01T12:00:00-03:00","author":{"@type":"Person","name":"Nicolás Antinori"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://nicoan.net/posts/when_leaking_memory_makes_sense/"},"publisher":{"@type":"Organization","name":"Nico Antinori","logo":{"@type":"ImageObject","url":"https://nicoan.net/assets/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://nicoan.net/ accesskey=h title="Nico Antinori (Alt + H)">Nico Antinori</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://nicoan.net/ title=Home><span>Home</span></a></li><li><a href=https://nicoan.net/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://nicoan.net/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://nicoan.net/series/ title=Series><span>Series</span></a></li><li><a href=https://nicoan.net/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">When leaking memory makes sense: Leaking memory in Rust</h1><div class=post-meta><span title='2025-04-01 12:00:00 -0300 -0300'>April 1, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Nicolás Antinori</div></header><div class=post-content><p>It is believed that it is impossible to leak memory with Rust, that is not true. Although is way more difficult to leak memory in Rust than in other languages, it can happen, sometimes by accident, and sometimes, by design. In this article we will explore some cases where leaking memory is useful.</p><h1 id=sharing-memory-between-threads>Sharing memory between threads<a hidden class=anchor aria-hidden=true href=#sharing-memory-between-threads>#</a></h1><p>Imagine that you have a value that it does not change and needs to be shared across several threads. If the value can be initialized with <a href=http://doc.rust-lang.org/reference/const_eval.html#const-functions>constant functions</a> or values, you can use the <a href=https://doc.rust-lang.org/std/keyword.static.html>static</a> keyword. But what if the value to be shared is not constant? What are the options?</p><h2 id=using-arc>Using Arc<a hidden class=anchor aria-hidden=true href=#using-arc>#</a></h2><p><a href=https://doc.rust-lang.org/std/sync/struct.Arc.html><code>Arc&lt;T></code></a> is a smart pointer that allow us to share a value safely between threads. ”<code>Arc</code>” stands for “Atomically Reference Counted”. The value owned by the <code>Arc</code> can be read from different threads. Every time an <code>Arc</code> is cloned, the internal counter is incremented by one, and every time an <code>Arc</code> is dropped, the internal counter is decremented by one. Once the counter goes from 1 to 0, the resource owned by the Arc is cleaned up. For example:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::env;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::sync::Arc;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::thread;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> name: String <span style=color:#f92672>=</span> env::args().collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span>().remove(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> person_name: <span style=color:#a6e22e>Arc</span><span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Arc::new(name);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> person_name.clone();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> t1 <span style=color:#f92672>=</span> thread::spawn(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;Hello </span><span style=color:#e6db74>{p}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> person_name.clone();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> t2 <span style=color:#f92672>=</span> thread::spawn(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;Bye </span><span style=color:#e6db74>{p}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> _ <span style=color:#f92672>=</span> t1.join();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> _ <span style=color:#f92672>=</span> t2.join();
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>This program receives a name by argument and spawns two threads that read that value. In this example there is no leak: Once the threads finish executing, the <code>Arc</code> is dropped and when the main thread exits, the value is cleaned up, since the <code>Arc</code> owned by the main function is the last reference to the name.</p><h2 id=leaking-memory-with-boxleak>Leaking memory with Box::leak<a hidden class=anchor aria-hidden=true href=#leaking-memory-with-boxleak>#</a></h2><p>Instead of creating an <code>Arc</code> and moving the clones where we need, we can leak the memory with <a href=https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak><code>Box::leak</code></a> and shared it with the threads:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span></span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::env;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::thread;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> name: String <span style=color:#f92672>=</span> env::args().collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span>().remove(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex;background-color:#3c3d38><span>    <span style=color:#66d9ef>let</span> person_name: <span style=color:#66d9ef>&amp;</span>&#39;static String <span style=color:#f92672>=</span> Box::leak(Box::new(name));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> t1 <span style=color:#f92672>=</span> thread::spawn(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;Hello </span><span style=color:#e6db74>{person_name}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> t2 <span style=color:#f92672>=</span> thread::spawn(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;Bye </span><span style=color:#e6db74>{person_name}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> _ <span style=color:#f92672>=</span> t1.join();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> _ <span style=color:#f92672>=</span> t2.join();
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>In line 6, we are leaking the memory creating an <em>static reference</em> and then we are moving it to the spawned threads so they can be read by them<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>The code showed above is just an example, an actual useful case for leaking memory and reading it from threads or async tasks is having a global configuration loaded at runtime that we know it won’t change for the entire execution of the program.</p><p>If we check this code with <a href=https://valgrind.org/>valgrind</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>valgrind ./target/release/box_leak John
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>691<span style=color:#f92672>==</span> Memcheck, a memory error detector
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>691<span style=color:#f92672>==</span> Copyright <span style=color:#f92672>(</span>C<span style=color:#f92672>)</span> 2002-2017, and GNU GPL<span style=color:#960050;background-color:#1e0010>&#39;</span>d, by Julian Seward et al.
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>691<span style=color:#f92672>==</span> Using Valgrind-3.16.1 and LibVEX; rerun with -h <span style=color:#66d9ef>for</span> copyright info
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>691<span style=color:#f92672>==</span> Command: ./target/release/box_leak John
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>691<span style=color:#f92672>==</span>
</span></span><span style=display:flex><span>Bye John
</span></span><span style=display:flex><span>Hello John
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>691<span style=color:#f92672>==</span>
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>691<span style=color:#f92672>==</span> HEAP SUMMARY:
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>691<span style=color:#f92672>==</span>     in use at exit: <span style=color:#ae81ff>28</span> bytes in <span style=color:#ae81ff>2</span> blocks
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>691<span style=color:#f92672>==</span>   total heap usage: <span style=color:#ae81ff>27</span> allocs, <span style=color:#ae81ff>25</span> frees, 4,229 bytes allocated
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>691<span style=color:#f92672>==</span>
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>691<span style=color:#f92672>==</span> LEAK SUMMARY:
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>691<span style=color:#f92672>==</span>    definitely lost: <span style=color:#ae81ff>24</span> bytes in <span style=color:#ae81ff>1</span> blocks
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>691<span style=color:#f92672>==</span>    indirectly lost: <span style=color:#ae81ff>4</span> bytes in <span style=color:#ae81ff>1</span> blocks
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>691<span style=color:#f92672>==</span>      possibly lost: <span style=color:#ae81ff>0</span> bytes in <span style=color:#ae81ff>0</span> blocks
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>691<span style=color:#f92672>==</span>    still reachable: <span style=color:#ae81ff>0</span> bytes in <span style=color:#ae81ff>0</span> blocks
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>691<span style=color:#f92672>==</span>         suppressed: <span style=color:#ae81ff>0</span> bytes in <span style=color:#ae81ff>0</span> blocks
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>691<span style=color:#f92672>==</span> Rerun with --leak-check<span style=color:#f92672>=</span>full to see details of leaked memory
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>691<span style=color:#f92672>==</span>
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>691<span style=color:#f92672>==</span> For lists of detected and suppressed errors, rerun with: -s
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>691<span style=color:#f92672>==</span> ERROR SUMMARY: <span style=color:#ae81ff>0</span> errors from <span style=color:#ae81ff>0</span> contexts <span style=color:#f92672>(</span>suppressed: <span style=color:#ae81ff>0</span> from 0<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>We effectively see that <strong>not all</strong> memory was freed.</p><h1 id=foreign-function-interfaces-ffi>Foreign Function Interfaces (FFI)<a hidden class=anchor aria-hidden=true href=#foreign-function-interfaces-ffi>#</a></h1><p>Libraries created in Rust can be used in other languages (commonly C) through <a href=https://doc.rust-lang.org/nomicon/ffi.html>Foreign Function Interfaces</a>. In other languages, the way of doing things are usually different than in Rust. For example, in C, exists the “<a href=https://en.wikipedia.org/wiki/Opaque_pointer>Opaque Pointer Pattern</a>”. The objetive of this pattern is to hide implementations details by using an <em>opaque pointer</em>. To implement this pattern we need a function to create a struct which details are hidden, functions to operate on the struct and a function to destroy it.</p><p>Suppose you want to reimplement a stack data structure, originally written in C, using Rust. Here’s the header file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#ifndef STACK_H
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define STACK_H
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdbool.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// This is the opaque type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> Stack Stack;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Stack <span style=color:#f92672>*</span><span style=color:#a6e22e>stack_create</span>(<span style=color:#66d9ef>int</span> capacity);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>stack_destroy</span>(Stack <span style=color:#f92672>*</span>stack);
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>stack_push</span>(Stack <span style=color:#f92672>*</span>stack, <span style=color:#66d9ef>int</span> value);
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>stack_pop</span>(Stack <span style=color:#f92672>*</span>stack, <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>out);
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>stack_peek</span>(<span style=color:#66d9ef>const</span> Stack <span style=color:#f92672>*</span>stack, <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>out);
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>stack_is_empty</span>(<span style=color:#66d9ef>const</span> Stack <span style=color:#f92672>*</span>stack);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span></code></pre></div><h2 id=data-representation>Data representation<a hidden class=anchor aria-hidden=true href=#data-representation>#</a></h2><p>To re-implement the stack library, we need to represent the stack in Rust and follow the interface from the header file. For this implementation, we&rsquo;ll use a <a href=https://doc.rust-lang.org/std/vec/struct.Vec.html>Vec</a> structure:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Stack</span> <span style=color:#f92672>=</span> Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span>;
</span></span></code></pre></div><h2 id=allocating-memory-and-leaking-it>Allocating memory and leaking it<a hidden class=anchor aria-hidden=true href=#allocating-memory-and-leaking-it>#</a></h2><p>Following the interface defined by the header file, we need to create a function that takes the capacity of the Stack and returns a pointer to it. This means that we need to allocate in memory some kind of data that represents a Stack structure (in this case a <code>Vec&lt;i32></code>) and return a pointer to it. This is implemented as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[unsafe(no_mangle)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>stack_create</span>(capacity: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> Stack {
</span></span><span style=display:flex><span>    Box::into_raw(Box::new(Vec::with_capacity(capacity)))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>What we do in this function is create the <code>Vec</code> with the capacity passed by argument, save it inside a <code>Box</code> and use <a href=https://doc.rust-lang.org/std/boxed/struct.Box.html#method.into_raw><code>Box::into_raw</code></a> to consume the Box and return a raw pointer to the vector. This means that the vector is allocated in memory and is accesible by our program, but now it is our responsibility to be sure that the pointer is allocated with the <code>Stack</code> representation when we want to use it and to release the memory when we do not need it anymore.</p><p>This is analogous to using <a href=https://en.cppreference.com/w/c/memory/malloc>malloc</a> to allocate memory for the data structure and initialize it with values in C.</p><h2 id=reclaiming-the-leaked-memory-to-release-it>Reclaiming the leaked memory to release it<a hidden class=anchor aria-hidden=true href=#reclaiming-the-leaked-memory-to-release-it>#</a></h2><p>If we do not free the <code>Stack</code> allocated by the function <code>stack_create</code>, we will indeed have created a memory leak. The header file declares a function to destroy it, here’s the implementation in Rust:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[unsafe(no_mangle)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>stack_destroy</span>(stack: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> Stack) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>stack.is_null() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> _ <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { Box::from_raw(stack) };
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here, if the stack pointer is not <code>null</code>, we reconstruct the <code>Box</code> to reclaim the ownership of the allocated memory. The created <code>Box</code> is immediately dropped, releasing the memory.</p><p>If we compile the <a href=https://github.com/nicoan/personal-site/blob/main/codes/rust_leak/stack_rust/src/main.c><code>main.c</code></a> program and verify it with <a href=https://valgrind.org/>valgrind</a>, we see that there’s no leak</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ valgrind ./main
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>580<span style=color:#f92672>==</span> Memcheck, a memory error detector
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>580<span style=color:#f92672>==</span> Copyright <span style=color:#f92672>(</span>C<span style=color:#f92672>)</span> 2002-2017, and GNU GPL<span style=color:#960050;background-color:#1e0010>&#39;</span>d, by Julian Seward et al.
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>580<span style=color:#f92672>==</span> Using Valgrind-3.16.1 and LibVEX; rerun with -h <span style=color:#66d9ef>for</span> copyright info
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>580<span style=color:#f92672>==</span> Command: ./main
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>580<span style=color:#f92672>==</span>
</span></span><span style=display:flex><span>Top of stack: <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>Popped: <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>Popped: 10
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>580<span style=color:#f92672>==</span>
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>580<span style=color:#f92672>==</span> HEAP SUMMARY:
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>580<span style=color:#f92672>==</span>     in use at exit: <span style=color:#ae81ff>0</span> bytes in <span style=color:#ae81ff>0</span> blocks
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>580<span style=color:#f92672>==</span>   total heap usage: <span style=color:#ae81ff>3</span> allocs, <span style=color:#ae81ff>3</span> frees, 1,056 bytes allocated
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>580<span style=color:#f92672>==</span>
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>580<span style=color:#f92672>==</span> All heap blocks were freed -- no leaks are possible
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>580<span style=color:#f92672>==</span>
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>580<span style=color:#f92672>==</span> For lists of detected and suppressed errors, rerun with: -s
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>580<span style=color:#f92672>==</span> ERROR SUMMARY: <span style=color:#ae81ff>0</span> errors from <span style=color:#ae81ff>0</span> contexts <span style=color:#f92672>(</span>suppressed: <span style=color:#ae81ff>0</span> from 0<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>We can see that there are no leaks! So, technically we did not leaked memory, it was just a temporal thing from the Rust perspective, and, from C’s perspective, we were simply allocating memory and freeing it correctly afterward.</p><p>You can find the full implementation of both C and Rust <a href=https://github.com/nicoan/personal-site/tree/main/codes/rust_leak>here</a>.</p><h2 id=can-boxleak-be-used-instead-of-boxinto_raw>Can <code>Box::leak</code> be used instead of <code>Box::into_raw</code>?<a hidden class=anchor aria-hidden=true href=#can-boxleak-be-used-instead-of-boxinto_raw>#</a></h2><p>Yes, but in my opinion you should not. Semantically, using <code>Box::from_raw</code> to re-create a <code>Box</code> from a <code>Box::leak</code> is incorrect because, technically, you did not intend to leak memory if you reclaim it with the objetive of releasing it. Check out the following code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>reconstruct_and_drop</span>(value: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> <span style=color:#66d9ef>i32</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> _ <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { Box::from_raw(value <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>i32</span>) };
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> value <span style=color:#f92672>=</span> Box::new(<span style=color:#ae81ff>42</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> static_value: <span style=color:#66d9ef>&amp;</span>&#39;static <span style=color:#a6e22e>mut</span> <span style=color:#66d9ef>i32</span> <span style=color:#f92672>=</span> Box::leak(value);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;The value is </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, static_value);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    reconstruct_and_drop(static_value);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;The value is </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, static_value);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This results in the following output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>The value is <span style=color:#ae81ff>42</span>
</span></span><span style=display:flex><span>The value is <span style=color:#ae81ff>431898688</span>
</span></span></code></pre></div><p>Here, we leak the value <code>42</code>, and we give it a <code>'static</code> lifetime. <a href="https://doc.rust-lang.org/stable/book/ch10-03-lifetime-syntax.html?highlight=%27static#the-static-lifetime">Citing the Rust Book</a>:</p><blockquote><p>But before specifying <code>'static</code> as the lifetime for a reference, <strong>think about whether the reference you have actually lives the entire lifetime of your program or not</strong>, and whether you want it to</p></blockquote><p>Additionally, by definition, a <a href=https://doc.rust-lang.org/stable/book/ch04-02-references-and-borrowing.html>reference</a> is valid throughout its entire lifetime, unlike a raw pointer.</p><blockquote><p>Unlike a pointer, a reference is guaranteed to point to a valid value of a particular type for the life of that reference.</p></blockquote><p>And <code>Box::leak</code> returns a reference that, as showed in the example above, we can invalidate. The example is very simple and the error can be spotted right away, but in a larger codebase, this could become a bug hard to find and fix.</p><p>In situations where we need a raw pointer and know we&rsquo;ll going to reclaim the memory to release it is semantically correct to use the <code>Box::into_raw</code> / <code>Box::from_raw</code> pair of functions.</p><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>Even though leaking memory can be an useful resource, it must be used with care. We can’t abuse this mechanism because we can create unintended problems, like running out of memory, or consuming too much of it without an specific purpose.</p><p>But, why re-implement things in Rust and use these tricks? This would require a whole article to explain, but the short answer is that even though you need to use <a href=https://doc.rust-lang.org/std/keyword.unsafe.html><code>unsafe</code></a> keyword from time to time, if used correctly, you still have a lot of compile-time checks and safety guarantees that Rust provides out of the box.</p><p>Lastly, a real-word scenario where this technique is used is the <a href=https://www.redox-os.org/>Redox OS</a>’s libc re-implementation un Rust called <a href=https://gitlab.redox-os.org/redox-os/relibc>relibc</a> (for example, in the <a href=https://pubs.opengroup.org/onlinepubs/009696599/functions/regcomp.html>regcomp</a> function <a href=https://gitlab.redox-os.org/redox-os/relibc/-/blob/28713e6bf186b9a22f873b6abe9654e97ac0db39/src/header/regex/mod.rs#L62>here’s</a> the <code>Box::into_raw</code>, and in the <a href=https://pubs.opengroup.org/onlinepubs/009696599/functions/regfree.html>regfree</a> function <a href=https://gitlab.redox-os.org/redox-os/relibc/-/blob/28713e6bf186b9a22f873b6abe9654e97ac0db39/src/header/regex/mod.rs#L83>here’s</a> the <code>Box::from_raw</code>)</p><h1 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h1><ol><li><a href=https://marabos.nl/atomics/basics.html#shared-ownership-and-reference-counting>https://marabos.nl/atomics/basics.html#shared-ownership-and-reference-counting</a></li></ol><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>You may wonder why we need to use the <a href=https://doc.rust-lang.org/std/keyword.move.html>move</a> keyword if we are creating an <code>’static</code> reference. Remember that closures capture their environment by reference, so what we are really capturing here is a <code>&&'static String</code> and not a <code>&'static String</code> where the <em>outer</em> reference is <strong>not</strong> <code>'static</code>.
When using move, we are “moving” <code>&'static String</code> into the thread, but, since they are references and references are <a href=https://doc.rust-lang.org/std/marker/trait.Copy.html>Copy</a>, we just copy the reference inside of the thread, not destroying it outside.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://nicoan.net/tags/rust/>Rust</a></li><li><a href=https://nicoan.net/tags/low-level/>Low-Level</a></li><li><a href=https://nicoan.net/tags/heap/>Heap</a></li><li><a href=https://nicoan.net/tags/leak/>Leak</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share When leaking memory makes sense: Leaking memory in Rust on x" href="https://x.com/intent/tweet/?text=When%20leaking%20memory%20makes%20sense%3a%20Leaking%20memory%20in%20Rust&amp;url=https%3a%2f%2fnicoan.net%2fposts%2fwhen_leaking_memory_makes_sense%2f&amp;hashtags=rust%2clow-level%2cheap%2cleak"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share When leaking memory makes sense: Leaking memory in Rust on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fnicoan.net%2fposts%2fwhen_leaking_memory_makes_sense%2f&amp;title=When%20leaking%20memory%20makes%20sense%3a%20Leaking%20memory%20in%20Rust&amp;summary=When%20leaking%20memory%20makes%20sense%3a%20Leaking%20memory%20in%20Rust&amp;source=https%3a%2f%2fnicoan.net%2fposts%2fwhen_leaking_memory_makes_sense%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share When leaking memory makes sense: Leaking memory in Rust on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fnicoan.net%2fposts%2fwhen_leaking_memory_makes_sense%2f&title=When%20leaking%20memory%20makes%20sense%3a%20Leaking%20memory%20in%20Rust"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share When leaking memory makes sense: Leaking memory in Rust on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fnicoan.net%2fposts%2fwhen_leaking_memory_makes_sense%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share When leaking memory makes sense: Leaking memory in Rust on whatsapp" href="https://api.whatsapp.com/send?text=When%20leaking%20memory%20makes%20sense%3a%20Leaking%20memory%20in%20Rust%20-%20https%3a%2f%2fnicoan.net%2fposts%2fwhen_leaking_memory_makes_sense%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share When leaking memory makes sense: Leaking memory in Rust on telegram" href="https://telegram.me/share/url?text=When%20leaking%20memory%20makes%20sense%3a%20Leaking%20memory%20in%20Rust&amp;url=https%3a%2f%2fnicoan.net%2fposts%2fwhen_leaking_memory_makes_sense%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share When leaking memory makes sense: Leaking memory in Rust on ycombinator" href="https://news.ycombinator.com/submitlink?t=When%20leaking%20memory%20makes%20sense%3a%20Leaking%20memory%20in%20Rust&u=https%3a%2f%2fnicoan.net%2fposts%2fwhen_leaking_memory_makes_sense%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://nicoan.net/>Nico Antinori</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>