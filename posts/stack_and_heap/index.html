<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Stack and Heap | Nico Antinori</title>
<meta name=keywords content="rust,low-level,heap,stack"><meta name=description content="Why write about Stack and Heap when there are already a lot of articles out there? I want to improve my writing skills so, I decided to write articles about things I find interesting. This article was supposed to be about how Rust manages memory through ownership. Then I thought &ldquo;I should first write about Stack and Heap&rdquo;. So, here we are).
To understand memory management first, we need to understand what the Stack and the Heap are."><meta name=author content="Nicolás Antinori"><link rel=canonical href=https://nicoan.net/posts/stack_and_heap/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://nicoan.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nicoan.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://nicoan.net/favicon-32x32.png><link rel=apple-touch-icon href=https://nicoan.net/apple-touch-icon.png><link rel=mask-icon href=https://nicoan.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://nicoan.net/posts/stack_and_heap/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Stack and Heap"><meta property="og:description" content="Why write about Stack and Heap when there are already a lot of articles out there? I want to improve my writing skills so, I decided to write articles about things I find interesting. This article was supposed to be about how Rust manages memory through ownership. Then I thought &ldquo;I should first write about Stack and Heap&rdquo;. So, here we are).
To understand memory management first, we need to understand what the Stack and the Heap are."><meta property="og:type" content="article"><meta property="og:url" content="https://nicoan.net/posts/stack_and_heap/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-26T12:00:00-03:00"><meta property="article:modified_time" content="2022-07-26T12:00:00-03:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Stack and Heap"><meta name=twitter:description content="Why write about Stack and Heap when there are already a lot of articles out there? I want to improve my writing skills so, I decided to write articles about things I find interesting. This article was supposed to be about how Rust manages memory through ownership. Then I thought &ldquo;I should first write about Stack and Heap&rdquo;. So, here we are).
To understand memory management first, we need to understand what the Stack and the Heap are."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://nicoan.net/posts/"},{"@type":"ListItem","position":2,"name":"Stack and Heap","item":"https://nicoan.net/posts/stack_and_heap/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Stack and Heap","name":"Stack and Heap","description":"Why write about Stack and Heap when there are already a lot of articles out there? I want to improve my writing skills so, I decided to write articles about things I find interesting. This article was supposed to be about how Rust manages memory through ownership. Then I thought \u0026ldquo;I should first write about Stack and Heap\u0026rdquo;. So, here we are).\nTo understand memory management first, we need to understand what the Stack and the Heap are.","keywords":["rust","low-level","heap","stack"],"articleBody":"Why write about Stack and Heap when there are already a lot of articles out there? I want to improve my writing skills so, I decided to write articles about things I find interesting. This article was supposed to be about how Rust manages memory through ownership. Then I thought “I should first write about Stack and Heap”. So, here we are).\nTo understand memory management first, we need to understand what the Stack and the Heap are. Stack and Heap are memory regions used by a process to store and read values. The memory of a running process can usually be divided in the following four regions:\nText: Here is where our program instructions live. Our compiled program is loaded and stored in this region of the memory. Data: All the global variables are stored in this region. Stack: A contiguous chunk of memory that stores local variables, arguments and return addresses of functions (we will go deeper on this in the next section). Every process’ thread has its own Stack. Heap: Stores all the dynamically allocated memory. This region is shared among all threads of a process. Stack A process’ Stack is an actual implementation of the Stack data structure. It is fixed in size; we can not ask the operating system for more memory. This size depends mostly on the OS. In modern Linux systems, the maximum Stack size is 8 MB (you can check yours with the command ulimit -s).\nInside the Stack Every time we call a function, a Stack frame (a chunk of contiguous memory containing all the information required by the recently called function) is created and placed on top of the Stack. And, every time a function ends, the Stack frame is popped from the Stack, automatically releasing all the memory used by it. Let’s see a minimal example on how the Stack is populated. Consider the following code:\nfn sum(a: i32, b: i32) -\u003e i32 { let result = a + b; result } fn square_sum(a: i32, b: i32) -\u003e i32 { let sum_result = sum(a, b); let pow_result = sum_result * sum_result; pow_result } fn main() { let n1 = 2; let n2 = 5; let pow_result = square_sum(n1, n2); println!(\"Result: {}\", pow_result); } The following diagram represents what happens with the Stack when the program is executed:\nAt the beginning, a Stack frame for the main function is created. main calls square_sum, a Stack frame for square_sum is created. square_sum calls sum, a Stack frame is created for sum. After sum is called, its Stack frame is destroyed, releasing automatically all the memory it occupied. After square_sum is called, its Stack frame is destroyed, releasing automatically all the memory it occupied. main prints the result and ends. The operating system frees up all the remaining memory. NOTE: Usually, the stack grow downwards!\nInside the Stack frame The Stack frame is where all the local variables, arguments, and return address (this is used by the running process to know where the next code instruction to be executed is, after the function call ends) of a function live. The good news is that the user does not have to worry about allocating or de-allocating the memory used by it (neither with Heap allocations in safe Rust, but that is for another post). Given that the Stack is fixed in size, we can only store data that its size is known at compile time. For dynamic sized data (such as vectors), Heap memory is used (only a pointer to that part of the Heap memory and maybe some metadata is saved into the Stack). Let’s expand the above Stack diagrams to show the stack frame of each function:\nHow do we use the memory contained in the frame? We have two pointers that helps us with that:\nStack Pointer (SP): Always points at the top of the Stack. When a Stack frame is created the new SP’s value is SP + size_of(new_Stack_frame). It will change any time a value is pushed onto or popped off the stack. When an executing function returns, it goes back to its previous size. Base Pointer (BP): Also known as Frame Pointer (FP). Points to the base of the current Stack frame. When a Stack frame is created, the BP gets the value SP had before adding the size of the new Stack frame. The BP is used to access the arguments and local variables of a function by adding/substracting the offset of the variable we want to access. For example, if we want to access the argument y, we need to read the address BP + 12 because, first, we have the return address that (let’s assume) is 4 bytes long, and then the argument x that is a 32 bits integer (4 bytes). The layout presented here is just an example. Although, in reality, the frames contain the same information, how the data is organized depends on the machine architecture and the application binary interface (ABI).\nThis StackOverflow answer shows how the frame is constructed using x86 assembly.\nHeap In this context, “Heap” has nothing to do with the Heap data structure, it is just a name for the free memory pool.\nThe Heap is not fixed in size. We can ask for more memory, as long as it is available in the system, and free it if the allocated values are not needed anymore. Unlike Stack, when we are working with the Heap we have to take care of the allocation and deallocation of memory (in Rust, most allocation/deallocation logic is hidden behind abstractions). When we use the Heap, we are dynamically allocating memory. This comes in very handy when we are dealing with data which size is unknown at compile time (i.e. user input). In opposition to the Stack, the memory allocations are not sequential.\nWhen a process wants to allocate some chunk of memory of a given size, the operating system first has to search for a free piece of memory with the needed size. After finding it, the OS locks it up (only that particular process can access that portion of the system memory) and returns the starting address of the block. This process leads to memory fragmentation (the data allocated in the Heap is not contiguous).\nWhen we use the Heap, we also store some data in the Stack (at least a pointer to the allocated data). Consider the following code:\nfn main() { let n1: Box\u003cu8\u003e = Box::new(42); let my_string = String::from(\"hello\"); println!(\"{} {}\", my_string, n1); } NOTE: A Box is a smart pointer to a heap allocated value.\nThe following diagram shows the allocations made in the Stack and the Heap:\nWriting and reading the Heap is slower than writing and reading the Stack for several reasons:\nFor memory allocation, a process has to make a system call and wait for the OS to complete the process described above. Using the allocated memory (for writing or reading) involves at least one indirection (following the pointer allocated in the Stack). Under the right conditions, a program can be optimized to store some parts of the Stack inside the processor’s cache, making writing/reading operations blazingly fast. Summary Stack Heap Fixed in size Can grow or shrink Allocations are in a contiguous block Allocation happens in “random” order Faster access time Slower access time Is thread local by default: every thread of a process has its own Stack. Can be used to share memory across threads ","wordCount":"1245","inLanguage":"en","datePublished":"2022-07-26T12:00:00-03:00","dateModified":"2022-07-26T12:00:00-03:00","author":{"@type":"Person","name":"Nicolás Antinori"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://nicoan.net/posts/stack_and_heap/"},"publisher":{"@type":"Organization","name":"Nico Antinori","logo":{"@type":"ImageObject","url":"https://nicoan.net/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://nicoan.net/ accesskey=h title="Nico Antinori (Alt + H)">Nico Antinori</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://nicoan.net/ title=Home><span>Home</span></a></li><li><a href=https://nicoan.net/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://nicoan.net/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://nicoan.net/series/ title=Series><span>Series</span></a></li><li><a href=https://nicoan.net/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Stack and Heap</h1><div class=post-meta><span title='2022-07-26 12:00:00 -0300 -03'>July 26, 2022</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Nicolás Antinori</div></header><div class=post-content><p>Why write about Stack and Heap when there are already a lot of articles out there? I want to improve my writing skills so, I decided to write articles about things I find interesting. This article was supposed to be about how Rust manages memory through <a href=https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html>ownership</a>. Then I thought &ldquo;I should first write about Stack and Heap&rdquo;. So, here we are).</p><p>To understand memory management first, we need to understand what the Stack and the Heap are. Stack and Heap are memory regions used by a process to store and read values. The memory of a running process can usually be divided in the following four regions:</p><p><img loading=lazy src=/images/stack/memory.png#center alt="Memory Regions"></p><ul><li><strong>Text</strong>: Here is where our program instructions live. Our compiled program is loaded and stored in this region of the memory.</li><li><strong>Data</strong>: All the global variables are stored in this region.</li><li><strong>Stack</strong>: A contiguous chunk of memory that stores local variables, arguments and return addresses of functions (we will go deeper on this in the next section). Every process&rsquo; thread has its own Stack.</li><li><strong>Heap</strong>: Stores all the dynamically allocated memory. This region is shared among all threads of a process.</li></ul><h1 id=stack>Stack<a hidden class=anchor aria-hidden=true href=#stack>#</a></h1><p>A process&rsquo; Stack is an actual implementation of the <a href=https://en.wikipedia.org/wiki/Stack_(abstract_data_type)>Stack data structure</a>. It is fixed in size; we can not ask the operating system for more memory. This size depends mostly on the OS. In modern Linux systems, the <strong>maximum</strong> Stack size is 8 MB (you can check yours with the command <code>ulimit -s</code>).</p><h2 id=inside-the-stack>Inside the Stack<a hidden class=anchor aria-hidden=true href=#inside-the-stack>#</a></h2><p>Every time we call a function, a <em>Stack frame</em> (a chunk of contiguous memory containing all the information required by the recently called function) is created and placed on top of the Stack. And, every time a function ends, the Stack frame is popped from the Stack, automatically releasing all the memory used by it. Let&rsquo;s see a minimal example on how the Stack is populated. Consider the following code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>sum</span>(a: <span style=color:#66d9ef>i32</span>, b: <span style=color:#66d9ef>i32</span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>    result
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>square_sum</span>(a: <span style=color:#66d9ef>i32</span>, b: <span style=color:#66d9ef>i32</span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> sum_result <span style=color:#f92672>=</span> sum(a, b);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> pow_result <span style=color:#f92672>=</span> sum_result <span style=color:#f92672>*</span> sum_result;
</span></span><span style=display:flex><span>    pow_result
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> n1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> n2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> pow_result <span style=color:#f92672>=</span> square_sum(n1, n2);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;Result: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, pow_result);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The following diagram represents what happens with the Stack when the program is executed:</p><p><img loading=lazy src=/images/stack/stack_1.png#center alt="Executing Stack"></p><ol><li>At the beginning, a Stack frame for the <code>main</code> function is created.</li><li><code>main</code> calls <code>square_sum</code>, a Stack frame for <code>square_sum</code> is created.</li><li><code>square_sum</code> calls <code>sum</code>, a Stack frame is created for <code>sum</code>.</li><li>After <code>sum</code> is called, its Stack frame is destroyed, releasing automatically all the memory it occupied.</li><li>After <code>square_sum</code> is called, its Stack frame is destroyed, releasing automatically all the memory it occupied.</li><li><code>main</code> prints the result and ends. The operating system frees up all the remaining memory.</li></ol><p><strong>NOTE</strong>: Usually, the stack grow downwards!</p><h2 id=inside-the-stack-frame>Inside the Stack frame<a hidden class=anchor aria-hidden=true href=#inside-the-stack-frame>#</a></h2><p>The Stack frame is where all the local variables, arguments, and return address (this is used by the running process to know where the next code instruction to be executed is, after the function call ends) of a function live. The good news is that the user does not have to worry about allocating or de-allocating the memory used by it (neither with Heap allocations in safe Rust, but that is for another post). Given that the Stack is fixed in size, we can only store data that its size is known at compile time. For dynamic sized data (such as <a href=https://doc.rust-lang.org/std/vec/struct.Vec.html>vectors</a>), Heap memory is used (only a pointer to that part of the Heap memory and <em>maybe</em> some metadata is saved into the Stack). Let&rsquo;s expand the above Stack diagrams to show the stack frame of each function:</p><p><img loading=lazy src=/images/stack/stack_2.png#center alt="Stack Frame"></p><p>How do we use the memory contained in the frame? We have two pointers that helps us with that:</p><ul><li><strong>Stack Pointer (SP)</strong>: Always points at the top of the Stack. When a Stack frame is created the new SP&rsquo;s value is <code>SP + size_of(new_Stack_frame)</code>. It will change any time a value is pushed onto or popped off the stack. When an executing function returns, it goes back to its previous size.</li><li><strong>Base Pointer (BP)</strong>: Also known as <em>Frame Pointer (FP)</em>. Points to the base of the current Stack frame. When a Stack frame is created, the BP gets the value SP had before adding the size of the new Stack frame. The <em>BP</em> is used to access the arguments and local variables of a function by adding/substracting the offset of the variable we want to access. For example, if we want to access the argument <code>y</code>, we need to read the address <code>BP + 12</code> because, first, we have the <code>return address</code> that (let&rsquo;s assume) is 4 bytes long, and then the argument <code>x</code> that is a 32 bits integer (4 bytes).</li></ul><p>The layout presented here is just an example. Although, in reality, the frames contain the same information, how the data is organized depends on the <a href=https://en.wikipedia.org/wiki/Calling_convention>machine architecture</a> and the <a href=https://en.wikipedia.org/wiki/Application_binary_interface>application binary interface (ABI)</a>.</p><p><a href=https://stackoverflow.com/questions/3699283/what-is-stack-frame-in-assembly#answer-3700219>This StackOverflow answer</a> shows how the frame is constructed using x86 assembly.</p><h1 id=heap>Heap<a hidden class=anchor aria-hidden=true href=#heap>#</a></h1><p>In this context, &ldquo;Heap&rdquo; has nothing to do with the Heap data structure, it is just a name for the free memory pool.</p><p>The Heap is not fixed in size. We can ask for more memory, as long as it is available in the system, and free it if the allocated values are not needed anymore. Unlike Stack, when we are working with the Heap we have to take care of the allocation and deallocation of memory (in Rust, <strong>most</strong> allocation/deallocation logic is hidden behind abstractions). When we use the Heap, we are dynamically allocating memory. This comes in very handy when we are dealing with data which size is unknown at compile time (i.e. user input). In opposition to the Stack, the memory allocations are not sequential.</p><p>When a process wants to allocate some chunk of memory of a given size, the operating system first has to search for a free piece of memory with the needed size. After finding it, the OS locks it up (only that particular process can access that portion of the system memory) and returns the starting address of the block. This process leads to <em>memory fragmentation</em> (the data allocated in the Heap is <strong>not</strong> contiguous).</p><p>When we use the Heap, we also store some data in the Stack (<em>at least</em> a pointer to the allocated data). Consider the following code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> n1: Box<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Box::new(<span style=color:#ae81ff>42</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> my_string <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74> </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, my_string, n1);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>NOTE</strong>: A <a href=https://doc.rust-lang.org/rust-by-example/std/box.html>Box</a> is a smart pointer to a heap allocated value.</p><p>The following diagram shows the allocations made in the Stack and the Heap:</p><p><img loading=lazy src=/images/stack/heap.png#center alt=Heap></p><p>Writing and reading the Heap is slower than writing and reading the Stack for several reasons:</p><ul><li>For memory allocation, a process has to make a system call and wait for the OS to complete the process described above.</li><li>Using the allocated memory (for writing or reading) involves at least one indirection (following the pointer allocated in the Stack).</li><li>Under the right conditions, a program can be optimized to store some parts of the Stack inside the processor&rsquo;s cache, making writing/reading operations blazingly fast.</li></ul><h1 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h1><table><thead><tr><th>Stack</th><th>Heap</th></tr></thead><tbody><tr><td>Fixed in size</td><td>Can grow or shrink</td></tr><tr><td>Allocations are in a contiguous block</td><td>Allocation happens in &ldquo;random&rdquo; order</td></tr><tr><td>Faster access time</td><td>Slower access time</td></tr><tr><td>Is thread local by default: every thread of a process has its own Stack.</td><td>Can be used to share memory across threads</td></tr></tbody></table></div><footer class=post-footer><ul class=post-tags><li><a href=https://nicoan.net/tags/rust/>Rust</a></li><li><a href=https://nicoan.net/tags/low-level/>Low-Level</a></li><li><a href=https://nicoan.net/tags/heap/>Heap</a></li><li><a href=https://nicoan.net/tags/stack/>Stack</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Stack and Heap on x" href="https://x.com/intent/tweet/?text=Stack%20and%20Heap&amp;url=https%3a%2f%2fnicoan.net%2fposts%2fstack_and_heap%2f&amp;hashtags=rust%2clow-level%2cheap%2cstack"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Stack and Heap on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fnicoan.net%2fposts%2fstack_and_heap%2f&amp;title=Stack%20and%20Heap&amp;summary=Stack%20and%20Heap&amp;source=https%3a%2f%2fnicoan.net%2fposts%2fstack_and_heap%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Stack and Heap on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fnicoan.net%2fposts%2fstack_and_heap%2f&title=Stack%20and%20Heap"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Stack and Heap on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fnicoan.net%2fposts%2fstack_and_heap%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Stack and Heap on whatsapp" href="https://api.whatsapp.com/send?text=Stack%20and%20Heap%20-%20https%3a%2f%2fnicoan.net%2fposts%2fstack_and_heap%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Stack and Heap on telegram" href="https://telegram.me/share/url?text=Stack%20and%20Heap&amp;url=https%3a%2f%2fnicoan.net%2fposts%2fstack_and_heap%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Stack and Heap on ycombinator" href="https://news.ycombinator.com/submitlink?t=Stack%20and%20Heap&u=https%3a%2f%2fnicoan.net%2fposts%2fstack_and_heap%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://nicoan.net/>Nico Antinori</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>