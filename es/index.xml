<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Sur v ¬Sur</title>
    <link>https://nicoan.github.io/es/</link>
    <description>Recent content on Sur v ¬Sur</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 18 Oct 2022 12:00:00 -0300</lastBuildDate><atom:link href="https://nicoan.github.io/es/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Rust ownership y move semantics</title>
      <link>https://nicoan.github.io/es/posts/move_semantics/</link>
      <pubDate>Tue, 18 Oct 2022 12:00:00 -0300</pubDate>
      
      <guid>https://nicoan.github.io/es/posts/move_semantics/</guid>
      <description>Ownership y move semantics son dos conceptos que hacen a Rust único. Para entender este tema, es mejor primero entender que son el Stack y el Heap en un nivel básico. ¡Escribí un post sobre eso!
Es un poco difícil acostumbrarse a estos mecanismos, porque fuerzan al programador a pensar en cosas en las que no se tiene que preocupar en otros lenguajes. ¡Suficiente introducción! vamos a ver de qué se trata todo esto.</description>
      <content:encoded><![CDATA[<p>Ownership y move semantics son dos conceptos que hacen a Rust único. Para entender este tema, es mejor primero entender que son el Stack y el Heap en un nivel básico. ¡Escribí un <a href="/es/posts/stack_and_heap">post</a> sobre eso!</p>
<p>Es un poco difícil acostumbrarse a estos mecanismos, porque fuerzan al programador a pensar en cosas en las que no se tiene que preocupar en otros lenguajes. ¡Suficiente introducción! vamos a ver de qué se trata todo esto.</p>
<h1 id="las-tres-reglas-de-ownership">Las tres reglas de ownership</h1>
<p>Existen tres reglas que gobiernan el sistema de ownership:</p>
<ol>
<li><strong>Todo valor inicializado tiene un dueño (owner)</strong>: Todo valor inicializado tiene una variable a la cual pertenece.¹</li>
<li><strong>Sólo hay <em>un</em> dueño por valor</strong>: No pueden existir dos o más variables que sean dueñas del <em>mismo</em> valor en memoria. No se puede compartir la posesión entre variables.²</li>
<li><strong>Si el scope de una variable termina, su valor se libera</strong>: Cuando un scope termina, todos los valores de las variables contenidas en ese scope se liberan automáticamente.</li>
</ol>
<p>¹ Pero no todas las variables son dueñas de un valor, éstas pueden contener sólo una referencia. Voy a hablar más en detalle de esto en el artículo &ldquo;Referencias y Borrowing&rdquo;.<br>
² En realidad se puede tener más de un dueño en Rust (sin usar <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html"><em>unsafe</em></a>). Se deben utilizar estructuras especiales como <a href="https://doc.rust-lang.org/stable/std/rc/struct.Rc.html">Rc</a> (de todas formas, los múltiples dueños no poseen el valor directamente).</p>
<p>¡Vamos a probar estas reglas! Pero antes de eso, un pequeño repaso de cómo se representa en memoria el tipo <code>String</code>:</p>
<p><img loading="lazy" src="/images/move_semantics/string_repr.png#center" alt="Representacion en memoria de String"  />
</p>
<p>donde:</p>
<ul>
<li><strong>ptr</strong>: Un puntero a la primera dirección del Heap donde esta alojado el texto (en este caso <code>hello</code>).</li>
<li><strong>len</strong>: Cuánta memoria, en bytes, el contenido del texto está utilizando en un momento dado.</li>
<li><strong>capacity</strong>: La cantidad total de memoria, en bytes, reservada para ese string.</li>
</ul>
<h3 id="gdb">GDB</h3>
<p>En este post voy a explorar qué está pasando en la memoria a través de <a href="https://en.wikipedia.org/wiki/GNU_Debugger">GNU Debugger (gdb)</a> con el comando especial <code>rust-gdb</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ rust-gdb ./target/debug/move_semantics
</code></pre></div><p>Dentro de GDB, voy a utilizar muchísimo el <a href="https://visualgdb.com/gdbreference/commands/x">comando x</a> y el valor <code>$sp</code> (Stack Pointer) para explorar el stack.</p>
<h2 id="regla-1-todo-valor-inicializado-tiene-un-dueño-owner">Regla 1: Todo valor inicializado tiene un dueño (owner).</h2>
<p>Dado el siguiente código:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">hello_world</span>() -&gt; <span style="color:#66d9ef">u32</span> {
    String::from(<span style="color:#e6db74">&#34;hello! I am a free initialized String!&#34;</span>);
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, <span style="color:#ae81ff">42</span>);
    <span style="color:#ae81ff">42</span>
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    hello_world();
}
</code></pre></td></tr></table>
</div>
</div><p>En la función <code>hello_world</code> tenemos un valor inicializado de tipo <code>String</code> que está libre(no asignado a ninguna variable). ¿Rust inicializó el valor en memoria o simplemente lo ignoró? No tenemos forma de usarlo, entonces&hellip; ¿Por qué Rust lo guardaría? ¡Vamos a ver qué sucede! Cuando compilamos este código vemos la siguiente advertencia:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">warning: unused <span style="color:#66d9ef">return</span> value of <span style="color:#e6db74">`</span>from<span style="color:#e6db74">`</span> that must be used
 --&gt; src/main.rs:2:5
  |
<span style="color:#ae81ff">2</span> |     String::from<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hello! I am a free initialized String!&#34;</span><span style="color:#f92672">)</span>;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  <span style="color:#f92672">=</span> note: <span style="color:#e6db74">`</span><span style="color:#75715e">#[warn(unused_must_use)]` on by default</span>
</code></pre></div><p>Rust nos advierte que debemos utilizar el valor retornado de <code>String::from</code>, de otro modo, no lo podremos acceder de ninguna forma. ¿Qué pasa en la memoria? Vamos a verlo con GDB!</p>
<p>Primero ponemos un breakpoint al principio de la función <code>hello_world</code> y ejecutamos la inicialización del <code>String</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Breakpoint 1, move_semantics::hello_world <span style="color:#f92672">()</span> at src/main.rs:2
<span style="color:#ae81ff">2</span>           String::from<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hello! I am a free initialized String!&#34;</span><span style="color:#f92672">)</span>;
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> n
<span style="color:#ae81ff">3</span>           println!<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;{}&#34;</span>, 42<span style="color:#f92672">)</span>;
</code></pre></div><p>En este punto, el <code>String</code> fue inicializado pero no está asignado a ninguna variable. ¡No tiene dueño! Vamos a ver qué pasa en el Stack:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span></span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span></span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> x/80ub $sp
0x7fffffffd980: <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">240</span>     <span style="color:#ae81ff">127</span>     <span style="color:#ae81ff">255</span>     <span style="color:#ae81ff">255</span>     <span style="color:#ae81ff">127</span>     <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>
0x7fffffffd988: <span style="color:#ae81ff">61</span>      <span style="color:#ae81ff">60</span>      <span style="color:#ae81ff">87</span>      <span style="color:#ae81ff">85</span>      <span style="color:#ae81ff">85</span>      <span style="color:#ae81ff">85</span>      <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>
<span style="display:block;width:100%;background-color:#3c3d38">0x7fffffffd990: <span style="color:#ae81ff">16</span>      <span style="color:#ae81ff">90</span>      <span style="color:#ae81ff">90</span>      <span style="color:#ae81ff">85</span>      <span style="color:#ae81ff">85</span>      <span style="color:#ae81ff">85</span>      <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>
</span><span style="display:block;width:100%;background-color:#3c3d38">0x7fffffffd998: <span style="color:#ae81ff">38</span>      <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>
</span><span style="display:block;width:100%;background-color:#3c3d38">0x7fffffffd9a0: <span style="color:#ae81ff">38</span>      <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>
</span>0x7fffffffd9a8: <span style="color:#ae81ff">2</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>
0x7fffffffd9b0: <span style="color:#ae81ff">48</span>      <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>
0x7fffffffd9b8: <span style="color:#ae81ff">96</span>      <span style="color:#ae81ff">255</span>     <span style="color:#ae81ff">255</span>     <span style="color:#ae81ff">255</span>     <span style="color:#ae81ff">255</span>     <span style="color:#ae81ff">255</span>     <span style="color:#ae81ff">255</span>     <span style="color:#ae81ff">255</span>
0x7fffffffd9c0: <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">240</span>     <span style="color:#ae81ff">127</span>     <span style="color:#ae81ff">255</span>     <span style="color:#ae81ff">255</span>     <span style="color:#ae81ff">127</span>     <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>
0x7fffffffd9c8: <span style="color:#ae81ff">5</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>
</code></pre></td></tr></table>
</div>
</div><p>Aparentemente el valor está ahí, parece ser que nuestro valor inicializado está desde la línea 4 a la 6: Las direcciones de memoria <code>0x7fffffffd998</code> y <code>0x7fffffffd9a0</code> (líneas 5 y 6) tienen guardado el valor 38 coincidiendo con el largo del String. ¡<code>0x7fffffffd990</code> (línea 4) debe ser la dirección del Heap donde está alojado el texto! Veamos qué hay dentro de esa dirección de memoria.</p>
<p>Primero, imprimimos dicha dirección en hexadecimal:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> x/xg 0x7fffffffd990
0x7fffffffd990:	0x00005555555a5a10
</code></pre></div><p>Luego, exploramos qué hay dentro:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> x/38cb 0x00005555555a5a10
0x5555555a5a10: <span style="color:#ae81ff">0</span> <span style="color:#e6db74">&#39;\000&#39;</span>        <span style="color:#ae81ff">0</span> <span style="color:#e6db74">&#39;\000&#39;</span>        <span style="color:#ae81ff">0</span> <span style="color:#e6db74">&#39;\000&#39;</span>        <span style="color:#ae81ff">0</span> <span style="color:#e6db74">&#39;\000&#39;</span>        <span style="color:#ae81ff">0</span> <span style="color:#e6db74">&#39;\000&#39;</span>        <span style="color:#ae81ff">0</span> <span style="color:#e6db74">&#39;\000&#39;</span>        <span style="color:#ae81ff">0</span> <span style="color:#e6db74">&#39;\000&#39;</span>        <span style="color:#ae81ff">0</span> <span style="color:#e6db74">&#39;\000&#39;</span>
0x5555555a5a18: <span style="color:#ae81ff">16</span> <span style="color:#e6db74">&#39;\020&#39;</span>       <span style="color:#ae81ff">80</span> <span style="color:#e6db74">&#39;P&#39;</span>  <span style="color:#ae81ff">90</span> <span style="color:#e6db74">&#39;Z&#39;</span>  <span style="color:#ae81ff">85</span> <span style="color:#e6db74">&#39;U&#39;</span>  <span style="color:#ae81ff">85</span> <span style="color:#e6db74">&#39;U&#39;</span>  <span style="color:#ae81ff">85</span> <span style="color:#e6db74">&#39;U&#39;</span>  <span style="color:#ae81ff">0</span> <span style="color:#e6db74">&#39;\000&#39;</span>        <span style="color:#ae81ff">0</span> <span style="color:#e6db74">&#39;\000&#39;</span>
0x5555555a5a20: <span style="color:#ae81ff">101</span> <span style="color:#e6db74">&#39;e&#39;</span> <span style="color:#ae81ff">101</span> <span style="color:#e6db74">&#39;e&#39;</span> <span style="color:#ae81ff">32</span> <span style="color:#e6db74">&#39; &#39;</span>  <span style="color:#ae81ff">105</span> <span style="color:#e6db74">&#39;i&#39;</span> <span style="color:#ae81ff">110</span> <span style="color:#e6db74">&#39;n&#39;</span> <span style="color:#ae81ff">105</span> <span style="color:#e6db74">&#39;i&#39;</span> <span style="color:#ae81ff">116</span> <span style="color:#e6db74">&#39;t&#39;</span> <span style="color:#ae81ff">105</span> <span style="color:#e6db74">&#39;i&#39;</span>
0x5555555a5a28: <span style="color:#ae81ff">97</span> <span style="color:#e6db74">&#39;a&#39;</span>  <span style="color:#ae81ff">108</span> <span style="color:#e6db74">&#39;l&#39;</span> <span style="color:#ae81ff">105</span> <span style="color:#e6db74">&#39;i&#39;</span> <span style="color:#ae81ff">122</span> <span style="color:#e6db74">&#39;z&#39;</span> <span style="color:#ae81ff">101</span> <span style="color:#e6db74">&#39;e&#39;</span> <span style="color:#ae81ff">100</span> <span style="color:#e6db74">&#39;d&#39;</span> <span style="color:#ae81ff">32</span> <span style="color:#e6db74">&#39; &#39;</span>  <span style="color:#ae81ff">83</span> <span style="color:#e6db74">&#39;S&#39;</span>
0x5555555a5a30: <span style="color:#ae81ff">116</span> <span style="color:#e6db74">&#39;t&#39;</span> <span style="color:#ae81ff">114</span> <span style="color:#e6db74">&#39;r&#39;</span> <span style="color:#ae81ff">105</span> <span style="color:#e6db74">&#39;i&#39;</span> <span style="color:#ae81ff">110</span> <span style="color:#e6db74">&#39;n&#39;</span> <span style="color:#ae81ff">103</span> <span style="color:#e6db74">&#39;g&#39;</span> <span style="color:#ae81ff">33</span> <span style="color:#e6db74">&#39;!&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>¡El <code>String</code> está <strong>casi</strong> ahí! Parece que el principio fue sobreescrito. No hay problema, ninguna variable es dueña de ese valor, no lo podemos acceder de ninguna forma, por lo que no importa qué suceda con el mismo.</p>
<p><strong>NOTA</strong>: La memoria fue explorada utilizando un binario construido para <em>debug</em>. No estoy seguro de qué pasa si se compila en modo <em>release</em>. Dado que el valor no se usa, creo que Rust no lo inicializa, como una forma de optimización.</p>
<h2 id="regla-2-sólo-hay-un-dueño-por-valor">Regla 2: Sólo hay un dueño por valor</h2>
<p>Dado el siguiente código:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// Creamos un nuevo valor, con s1 como dueño
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello world!&#34;</span>);
    <span style="color:#75715e">// Movemos la posesión del valor a s2
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> s1;
    <span style="color:#75715e">// Oops! error al compilar, el valor fue movido!
</span><span style="color:#75715e"></span>    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, s1);
}
</code></pre></td></tr></table>
</div>
</div><p>Cuando lo intentamos obtenemos:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">error<span style="color:#f92672">[</span>E0382<span style="color:#f92672">]</span>: borrow of moved value: <span style="color:#e6db74">`</span>s1<span style="color:#e6db74">`</span>
 --&gt; src/main.rs:7:20
  |
<span style="color:#ae81ff">3</span> |     let s1 <span style="color:#f92672">=</span> String::from<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hello world!&#34;</span><span style="color:#f92672">)</span>;
  |         -- move occurs because <span style="color:#e6db74">`</span>s1<span style="color:#e6db74">`</span> has type <span style="color:#e6db74">`</span>String<span style="color:#e6db74">`</span>, which does not implement the <span style="color:#e6db74">`</span>Copy<span style="color:#e6db74">`</span> trait
<span style="color:#ae81ff">4</span> |     // Move ownership from s1 to s2
<span style="color:#ae81ff">5</span> |     let s2 <span style="color:#f92672">=</span> s1;
  |              -- value moved here
<span style="color:#ae81ff">6</span> |     // Oops! compiler error, the value has been moved!
<span style="color:#ae81ff">7</span> |     println!<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;{}&#34;</span>, s1<span style="color:#f92672">)</span>;
  |                    ^^ value borrowed here after move
</code></pre></div><p>Lo que está sucediendo es que la posesión del <code>String</code> <code>&quot;hello world!&quot;</code> es transferida de <code>s1</code> a <code>s2</code>. Por ese motivo, el compilador invalida el acceso a <code>s1</code>.</p>
<p>El valor fue movido porque el tipo <code>String</code> no implementa el trait <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html">Copy</a>. Este trait es utilizado en tipos que pueden ser completamente alojados en el Stack y pueden ser duplicados simplemente copiando sus bits sin mucha sobrecarga (duplicar datos en el Heap es bastante más complicado). Cuando un tipo implementa el trait <code>Copy</code>, en lugar comportarse con &ldquo;semántica de movimiento&rdquo; (move semantics) se comporta con &ldquo;semántica de copiado&rdquo; (copy semantics). Este suele ser el caso para los tipos primitivos:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> n1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
    <span style="color:#66d9ef">let</span> n2 <span style="color:#f92672">=</span> n1;
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, n1);
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{} {}&#34;</span>, n1, n2);
}
</code></pre></td></tr></table>
</div>
</div><p>Si corremos este código&hellip;</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">cargo run
   Compiling move_semantics v0.1.0 <span style="color:#f92672">(</span>/home/rust/blog<span style="color:#f92672">)</span>
    Finished dev <span style="color:#f92672">[</span>unoptimized + debuginfo<span style="color:#f92672">]</span> target<span style="color:#f92672">(</span>s<span style="color:#f92672">)</span> in 0.30s
     Running <span style="color:#e6db74">`</span>target/debug/move_semantics<span style="color:#e6db74">`</span>
<span style="color:#ae81ff">42</span>
<span style="color:#ae81ff">42</span> <span style="color:#ae81ff">42</span>
</code></pre></div><p>¡Compila! Porque el valor <code>42</code> es copiado.</p>
<h2 id="regla-3-si-el-scope-de-una-variable-termina-su-valor-se-libera">Regla 3: Si el scope de una variable termina, su valor se libera</h2>
<p>Dado el siguiente código:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    {
        <span style="color:#75715e">// Creamos un nuevo valor con s1 como dueña
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello world!&#34;</span>);
    } <span style="color:#75715e">// s1 se libera aca! por ser el final del scope
</span><span style="color:#75715e"></span>
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Checking drop with gdb!&#34;</span>);
}
</code></pre></td></tr></table>
</div>
</div><p>La memoria que ocupaba <code>s1</code> ya va a haber sido liberada cuando la ejecución llegue a la línea 7. Esto es porque las llaves al principio de la función <code>main</code> crean un nuevo scope. Una vez que éste termina, todas las variables que contenía se liberan. Veámoslo en GDB:</p>
<p>En la línea 4, podemos encontrar a <code>s1</code> en las variables locales del scope:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Breakpoint 1, move_semantics::main <span style="color:#f92672">()</span> at src/main.rs:4
4	        println!<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;{}&#34;</span>, s1<span style="color:#f92672">)</span>;
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> info locals
s1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello world!&#34;</span>
</code></pre></div><p>Veamos ahora, en qué dirección del Heap se encuentra alojado <code>s1</code> y qué contiene (recuerden que el primer campo de un <code>String</code> de su representación en el Stack es el puntero al Heap):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> p &amp;s1
$1 <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>*mut alloc::string::String<span style="color:#f92672">)</span> 0x7fffffffd960
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> x/xg 0x7fffffffd960
0x7fffffffd960:	0x00005555555a5ad0
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> x/12c 0x00005555555a5ad0
0x5555555a5ad0:	<span style="color:#ae81ff">104</span> <span style="color:#e6db74">&#39;h&#39;</span>	<span style="color:#ae81ff">101</span> <span style="color:#e6db74">&#39;e&#39;</span>	<span style="color:#ae81ff">108</span> <span style="color:#e6db74">&#39;l&#39;</span>	<span style="color:#ae81ff">108</span> <span style="color:#e6db74">&#39;l&#39;</span>	<span style="color:#ae81ff">111</span> <span style="color:#e6db74">&#39;o&#39;</span>	<span style="color:#ae81ff">32</span> <span style="color:#e6db74">&#39; &#39;</span>	<span style="color:#ae81ff">119</span> <span style="color:#e6db74">&#39;w&#39;</span>	<span style="color:#ae81ff">111</span> <span style="color:#e6db74">&#39;o&#39;</span>
0x5555555a5ad8:	<span style="color:#ae81ff">114</span> <span style="color:#e6db74">&#39;r&#39;</span>	<span style="color:#ae81ff">108</span> <span style="color:#e6db74">&#39;l&#39;</span>	<span style="color:#ae81ff">100</span> <span style="color:#e6db74">&#39;d&#39;</span>	<span style="color:#ae81ff">33</span> <span style="color:#e6db74">&#39;!&#39;</span>
</code></pre></div><p>Pero cuando el scope termina&hellip;</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">7	    println!<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Checking drop with gdb!&#34;</span><span style="color:#f92672">)</span>;
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> info locals
No locals.
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> x/12c 0x00005555555a5ad0
0x5555555a5ad0:	<span style="color:#ae81ff">0</span> <span style="color:#e6db74">&#39;\000&#39;</span>	<span style="color:#ae81ff">0</span> <span style="color:#e6db74">&#39;\000&#39;</span>	<span style="color:#ae81ff">0</span> <span style="color:#e6db74">&#39;\000&#39;</span>	<span style="color:#ae81ff">0</span> <span style="color:#e6db74">&#39;\000&#39;</span>	<span style="color:#ae81ff">0</span> <span style="color:#e6db74">&#39;\000&#39;</span>	<span style="color:#ae81ff">0</span> <span style="color:#e6db74">&#39;\000&#39;</span>	<span style="color:#ae81ff">0</span> <span style="color:#e6db74">&#39;\000&#39;</span>	<span style="color:#ae81ff">0</span> <span style="color:#e6db74">&#39;\000&#39;</span>
0x5555555a5ad8:	<span style="color:#ae81ff">16</span> <span style="color:#e6db74">&#39;\020&#39;</span>	<span style="color:#ae81ff">80</span> <span style="color:#e6db74">&#39;P&#39;</span>	<span style="color:#ae81ff">90</span> <span style="color:#e6db74">&#39;Z&#39;</span>	<span style="color:#ae81ff">85</span> <span style="color:#e6db74">&#39;U&#39;</span>
</code></pre></div><p>¡Todas las variables locales fueron liberadas! Es por ese motivo que esa parte del Heap está lleno con otra cosa (probablemente basura).</p>
<h1 id="moviendo-un-valor-qué-pasa-por-detrás">Moviendo un valor. ¿Qué pasa por detrás?</h1>
<p>Dado el siguiente código:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">move_stack_example</span>() {
    <span style="color:#75715e">// Creamos un nuevo valor de tipo String
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello world!&#34;</span>);
    <span style="color:#75715e">// Lo movemos de s1 a s2
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> s1;

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, s2);
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    move_stack_example();
}
</code></pre></td></tr></table>
</div>
</div><p>Cuando movemos un valor, éste no desaparece de la memoria, sino que toda su representación <em>en el Stack</em> se duplica y el compilador nos prohíbe acceder a la vieja variable de nuevo.</p>
<p><img loading="lazy" src="/images/move_semantics/es/under_the_hood.png#center" alt="Detras de escena"  />
</p>
<p>Vamos a verificar lo que acabo de decir con GDB. Para esto, examinaremos el stack frame de la función <code>move_stack_example</code>. Antes que nada, veamos qué variables locales están definidas:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> info locals
s2 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello world!&#34;</span>
s1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello world!&#34;</span>
</code></pre></div><p>¡Wow, parece que <code>s1</code> y <code>s2</code> contienen el mismo valor! En realidad están <strong>apuntando</strong> al mismo valor. Vamos a ver qué direcciones de memoria tomaron <code>s1</code> y <code>s2</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> p &amp;s1
$1 <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>*mut alloc::string::String<span style="color:#f92672">)</span> 0x7fffffffdb08
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> p &amp;s2
$2 <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>*mut alloc::string::String<span style="color:#f92672">)</span> 0x7fffffffdb20
</code></pre></div><p>¡Fantástico! Ahora sabemos que la representación de <code>s1</code> en el stack empieza en la dirección <code>0x7fffffffdb08</code> y la representación de <code>s2</code> empieza en <code>0x7fffffffdb20</code>. Vamos ahora a ver el contenido del frame:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span></span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span></span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span></span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span></span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span></span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> x/80bu $sp
0x7fffffffdaf0:	112	171	217	247	255	127	0	<span style="color:#ae81ff">0</span>
0x7fffffffdaf8:	7	125	221	247	255	127	0	<span style="color:#ae81ff">0</span>
0x7fffffffdb00:	2	0	0	0	0	0	0	<span style="color:#ae81ff">0</span>
<span style="display:block;width:100%;background-color:#3c3d38">0x7fffffffdb08:	208	90	90	85	85	85	0	<span style="color:#ae81ff">0</span>
</span><span style="display:block;width:100%;background-color:#3c3d38">0x7fffffffdb10:	12	0	0	0	0	0	0	<span style="color:#ae81ff">0</span>
</span><span style="display:block;width:100%;background-color:#3c3d38">0x7fffffffdb18:	12	0	0	0	0	0	0	<span style="color:#ae81ff">0</span>
</span><span style="display:block;width:100%;background-color:#3c3d38">0x7fffffffdb20:	208	90	90	85	85	85	0	<span style="color:#ae81ff">0</span>
</span><span style="display:block;width:100%;background-color:#3c3d38">0x7fffffffdb28:	12	0	0	0	0	0	0	<span style="color:#ae81ff">0</span>
</span><span style="display:block;width:100%;background-color:#3c3d38">0x7fffffffdb30:	12	0	0	0	0	0	0	<span style="color:#ae81ff">0</span>
</span>0x7fffffffdb38:	0	0	0	0	0	0	0	<span style="color:#ae81ff">0</span>
</code></pre></td></tr></table>
</div>
</div><p>¿Qué tenemos en dichas direcciones? ¡La representación en memoria del tipo <code>String</code>! Veamos:</p>
<ul>
<li><strong>ptr</strong>:
<ul>
<li>Para <code>s1</code> este valor está en <code>0x7fffffffdb08</code>.</li>
<li>Para <code>s2</code> este valor está en <code>0x7fffffffdb20</code>.</li>
</ul>
</li>
<li><strong>len</strong>:
<ul>
<li>Para <code>s1</code> este valor está en <code>0x7fffffffdb10</code>.</li>
<li>Para <code>s2</code> este valor está en <code>0x7fffffffdb28</code>.</li>
</ul>
</li>
<li><strong>capacity</strong>:
<ul>
<li>Para <code>s1</code> este valor está en <code>0x7fffffffdb18</code>.</li>
<li>Para <code>s2</code> este valor está en <code>0x7fffffffdb30</code>.</li>
</ul>
</li>
</ul>
<p>Como pueden observar, ambos valores de <code>ptr</code> son iguales, lo cuál significa que las dos variables apuntan a los mismos datos en el Heap. Vamos a imprimir estos valores en hexadecimal para obtener el formato correcto para poder explorarlo:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> x/xg 0x7fffffffdb08
0x7fffffffdb08: 0x00005555555a5ad0
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> x/xg 0x7fffffffdb20
0x7fffffffdb20: 0x00005555555a5ad0
</code></pre></div><p>¡El valor de <code>ptr</code> es <code>0x00005555555a5ad0</code>! Ahora vamos a ver el contenido de dicha dirección del Heap:</p>
<pre><code>(gdb) x/12c     0x00005555555a5ad0
0x5555555a5ad0:	104 'h'	101 'e'	108 'l'	108 'l'	111 'o'	32 ' '	119 'w'	111 'o'
0x5555555a5ad8:	114 'r'	108 'l'	100 'd'	33 '!'
</code></pre><p>¡El texto <code>hello world!</code> está ahí!</p>
<h1 id="conclusión">Conclusión</h1>
<p>Puede tomar algo de tiempo acostumbrarse a <em>ownership</em> y <em>move semantics</em>, pero en mi opinión, es tiempo bien invertido. Manejar la memoria de forma manual no es una tarea fácil y puede llevat a tener <a href="https://en.wikipedia.org/wiki/Manual_memory_management#Manual_management_and_correctness">muchos bugs</a>. Con el enfoque de Rust, estos bugs son detectados en tiempo de compilación para que nunca puedan pasar.
Si querés leer más sobre este tema <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">el libro de Rust</a> tiene un capítulo completamente dedicado.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Stack y Heap</title>
      <link>https://nicoan.github.io/es/posts/stack_and_heap/</link>
      <pubDate>Tue, 26 Jul 2022 12:00:00 -0300</pubDate>
      
      <guid>https://nicoan.github.io/es/posts/stack_and_heap/</guid>
      <description>¿Por qué escribir sobre Stack y Heap cuando ya existen pila (pun intended) de artículos en internet? Quiero mejorar mi escritura, y para cumplir este objetivo, decidí escribir artículos sobre cosas que encuentro interesantes. La idea es mejorar mi escritura tanto en inglés (ver arriba a la derecha, hay un link a este mismo artículo en dicho idioma) como en español. Originalmente, este post iba a tratar sobre cómo Rust maneja la memoria a través de lo que se conoce como ownership, pero luego pensé &amp;ldquo;debería primero escribir sobre Stack y Heap&amp;rdquo;.</description>
      <content:encoded><![CDATA[<p>¿Por qué escribir sobre Stack y Heap cuando ya existen pila (<em>pun intended</em>) de artículos en internet? Quiero mejorar mi escritura, y para cumplir este objetivo, decidí escribir artículos sobre cosas que encuentro interesantes. La idea es mejorar mi escritura tanto en inglés (ver arriba a la derecha, hay un link a este mismo artículo en dicho idioma) como en español. Originalmente, este post iba a tratar sobre cómo Rust maneja la memoria a través de lo que se conoce como <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">ownership</a>, pero luego pensé &ldquo;debería primero escribir sobre Stack y Heap&rdquo;.</p>
<p>Para entender cómo administrar el uso de memoria, primero tenemos que entender qué son el Stack y el Heap. Stack y Heap son regiones de memoria utilizadas por procesos para guardar y leer valores. La memoria de un proceso normalmente se puede dividir en cuatro regiones:</p>
<p><img loading="lazy" src="/images/stack/memory.png#center" alt="Regiones de memoria"  />
</p>
<ul>
<li><strong>Text</strong>: Aquí viven las instrucciones del nuestro programa. El programa ya compilado se carga y guarda en esta región.</li>
<li><strong>Data</strong>: Todas las variables globales se guardan en esta región.</li>
<li><strong>Stack</strong>: Es un pedazo contíguo de memoria. En esta región se guardan las variables locales, argumentos y dirección de retorno de las funciones (vamos a ver esto más detalladamente en la próxima sección). Cada hilo de ejecución de un proceso tiene su propio Stack.</li>
<li><strong>Heap</strong>: Guarda todos los valores de memoria que fueron asignados dinámicamente. Esta región es compartida por todos los hilos de un proceso.</li>
</ul>
<h1 id="stack">Stack</h1>
<p>El Stack de un proceso es una implementación real de la <a href="https://es.wikipedia.org/wiki/Pila_(inform%C3%A1tica)">estructura de datos homónima</a>. Su tamaño es fijo; no podemos pedirle al sistema operativo más memoria. Este tamaño depende principalmente del SO. En sistemas Linux modernos, el tamaño <strong>máximo</strong> es de 8 MB (esto se puede verificar utilizando el comando <code>ulimit -s</code>)</p>
<h2 id="dentro-del-stack">Dentro del Stack</h2>
<p>Cada vez que llamamos a una función, un <em>Stack frame</em> (un pedazo de memoria contíguo que contiene toda la información requerida por la función recientemente llamada) es creado y puesto en la parte superior del Stack. Este proceso también sucede de forma inversa, es decir, cada vez que una función termina, el Stack frame es eliminado del Stack, liberando automáticamente toda la memoria utilizada por éste. A continuación veremos un ejemplo simple de cómo el Stack se va llenando. Consideremos el siguiente programa:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">sum</span>(a: <span style="color:#66d9ef">i32</span>, b: <span style="color:#66d9ef">i32</span>) -&gt; <span style="color:#66d9ef">i32</span> {
    <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> a <span style="color:#f92672">+</span> b;
    result
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">square_sum</span>(a: <span style="color:#66d9ef">i32</span>, b: <span style="color:#66d9ef">i32</span>) -&gt; <span style="color:#66d9ef">i32</span> {
    <span style="color:#66d9ef">let</span> sum_result <span style="color:#f92672">=</span> sum(a, b);
    <span style="color:#66d9ef">let</span> pow_result <span style="color:#f92672">=</span> sum_result <span style="color:#f92672">*</span> sum_result;
    pow_result
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> n1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
    <span style="color:#66d9ef">let</span> n2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
    <span style="color:#66d9ef">let</span> pow_result <span style="color:#f92672">=</span> square_sum(n1, n2);
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Result: {}&#34;</span>, pow_result);
}
</code></pre></div><p>El siguiente diagrama representa qué pasa con el Stack cuando el programa es ejecutado:</p>
<p><img loading="lazy" src="/images/stack/stack_1.png#center" alt="Stack en accion"  />
</p>
<ol>
<li>Al principio, un Stack frame para la función <code>main</code> es creado.</li>
<li><code>main</code> llama a <code>square_sum</code>, un Stack frame para <code>square_sum</code> es creado.</li>
<li><code>square_sum</code> llama a <code>sum</code>, un Stack frame es creado para <code>sum</code>.</li>
<li>Al terminar <code>sum</code>, su Stack frame es destruido, liberando automáticamente toda la memoria ocupada por esta función.</li>
<li>Al terminar <code>square_sum</code>, su Stack frame es destruido, liberando automáticamente toda la memoria ocupada por esta función.</li>
<li><code>main</code> imprime el resultado y el programa termina. El sistema operativo libera toda la memoria restante utilizada por el proceso que ejecutaba nuestro programa.</li>
</ol>
<p><strong>NOTA</strong>: Normalmente el stack crece hacia abajo!</p>
<h2 id="dentro-del-stack-frame">Dentro del Stack frame</h2>
<p>El Stack frame es donde todas las variables locales, argumentos y dirección de retorno (ésta es utilizada para saber cuál es la siguiente instrucción a ejecutar luego de que una llamada a función termina) de una función viven. Las buenas noticias son que el usuario no debe preocuparse por asignar o liberar la memoria utilizada por éste (si utilizamos safe Rust, tampoco lo debe hacer para asignaciones en el Heap, pero eso es para otro artículo). Dado que el Stack tiene un tamaño fijo, sólo podemos guardar datos cuyo tamaño es conocido en <a href="https://es.wikipedia.org/wiki/Tiempo_de_compilaci%C3%B3n">tiempo de compilación</a>. Para datos de tamaño variable (por ejemplo, <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">vectores</a>), el Heap es utilizado (sólo un puntero a esa parte del Heap y <em>tal vez</em> algo de metadata es guardada en el Stack). A continuación vamos a expandir los diagramas presentados más arriba para mostrar el Stack frame de cada función:</p>
<p><img loading="lazy" src="/images/stack/es/stack_2.png#center" alt="Stack Frame"  />
</p>
<p>¿Cómo utilizamos la memoria contenida en un frame? Existen dos punteros que nos ayudan con eso:</p>
<ul>
<li><strong>Stack Pointer (SP)</strong>: Siempre apunta al tope del Stack. Cuando un Stack frame es creado, el nuevo valor de SP es <code>SP + size_of(new_Stack_frame)</code>. Este valor cambia cada vez que insertamos o quitamos un elemento. Cuando una función termina su ejecución, vuelve al valor que tenía antes de la llamada.</li>
<li><strong>Base Pointer (BP)</strong>: También conocido como <em>Frame Pointer (FP)</em>. Apunta a la base del último Stack frame. Cuando un Stack frame es creado, el <em>BP</em> es usado para acceder a los argumentos y variables locales de una función sumando/restando la posición de la variable que queremos acceder respecto al mismo <em>BP</em>. Por ejemplo, si queremos acceder al argumento <code>y</code>, necesitamos leer la dirección <code>BP + 12</code> porque, primero, tenemos la <code>dirección de retorno</code> que (asumimos) tiene un tamaño de 4 bytes, y luego, tenemos el argumento <code>x</code>, el cuál es un entero de 32 bits (4 bytes).</li>
</ul>
<p>La estructura presentada aquí es sólo un ejemplo. Aunque en la realidad los Stack frames contienen la misma información, cómo los datos son organizados dependen de la <a href="(https://en.wikipedia.org/wiki/Calling_convention)">arquitectura de la máquina</a> y de la <a href="https://es.wikipedia.org/wiki/Interfaz_binaria_de_aplicaciones">interfaz binaria de aplicación (ABI por sus siglas en inglés)</a>.</p>
<p><a href="https://stackoverflow.com/questions/3699283/what-is-stack-frame-in-assembly#answer-3700219">Esta respuesta de StackOverflow</a> muestra cómo el Stack frame es construido utilizando x86 assembly.</p>
<h1 id="heap">Heap</h1>
<p>En este contexto, &ldquo;Heap&rdquo; no tiene nada que ver con la estructura de datos Heap. Es sólo el nombre para la región de memoria &ldquo;libre&rdquo;.</p>
<p>El Heap no tiene un tamaño fijo. Podemos pedir más memoria, siempre y cuando esté disponible en el sistema, y liberarla si no necesitamos más los valores contenidos en ésta. A diferencia del Stack, cuando trabajamos con el Heap tenemos que admnistrar la asignación/liberación de memoria (en Rust, <strong>la mayoría</strong> de las asignaciones/liberaciones están escondidas detrás de abstracciones). Cuando utilizamos el Heap, estamos asignando memoria dinámicamente. Esto es muy conveniente cuando trabajamos con datos cuyo tamaño es desconocido en tiempo de compilación (como por ejemplo, texto ingresado por un usuario). Otra diferencia es que, las asignaciones de memoría <strong>no</strong> son secuenciales.</p>
<p>Cuando un proceso quiere asignar un pedazo de memoria de un tamaño determinado, el sistema operativo primero debe buscar una porción de memoria libre del volumen requerido. Luego de encontrarla, el SO bloquea dicha memoria (sólo el proceso que la pidió la puede acceder) y retorna la dirección correspondiente al primer bloque de ésta. Este proceso nos lleva al problema conocido como <em>fragmentación de memoria</em> (los datos guardados en el Heap <strong>no</strong> son contíguos).</p>
<p>Cuando utilizamos el Heap, también guardamos algunos datos en el Stack (<em>al menos</em> un puntero a los datos alojados en el Heap). Consideremos el siguiente código:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> n1: Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> Box::new(<span style="color:#ae81ff">42</span>);
    <span style="color:#66d9ef">let</span> my_string <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello&#34;</span>);

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{} {}&#34;</span>, my_string, n1);
}
</code></pre></div><p><strong>NOTA</strong>: Un <a href="https://doc.rust-lang.org/rust-by-example/std/box.html">Box</a> es un <em><a href="https://es.wikipedia.org/wiki/Puntero_inteligente">puntero inteligente</a></em> hacia un valor alojado en el Heap.</p>
<p>El siguiente diagrama muestra las asignaciones hechas por el programa en el Stack y el Heap:</p>
<p><img loading="lazy" src="/images/stack/es/heap.png#center" alt="Heap"  />
</p>
<p>Escribir y leer el Heap es más lento que escribir y leer el Stack por varias razones:</p>
<ul>
<li>Para la asignación de memoria, un proceso tiene que hacer una llamada al sistema y esperar que el sistema operativo complete el proceso descripto más arriba.</li>
<li>Para utilizar la memoria (sea para escribir o leer), tenemos al menos un nivel de indirección (seguir el puntero alojado en el Stack).</li>
<li>Bajo las condiciones correctas, un programa puede ser optimizado para guardar algunas partes del Stack dentro de la caché del procesador, haciendo las lecturas/escrituras increíblemente rápidas.</li>
</ul>
<h1 id="resumen">Resumen</h1>
<table>
<thead>
<tr>
<th>Stack</th>
<th>Heap</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tamaño fijo</td>
<td>Tamaño variable</td>
</tr>
<tr>
<td>Las asignaciones son contiguas</td>
<td>Las asignaciones suceden en orden &ldquo;aleatorio&rdquo;</td>
</tr>
<tr>
<td>Tiempo de acceso rápido</td>
<td>Tiempo de acceso lento</td>
</tr>
<tr>
<td>Es &ldquo;thread safe&rdquo; por definición</td>
<td>Puede ser utilizado para compartir memoria entre procesos</td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    
    
  </channel>
</rss>
