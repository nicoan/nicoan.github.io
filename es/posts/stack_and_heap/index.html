<!doctype html><html lang=es dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Stack y Heap | Nico Antinori</title>
<meta name=keywords content><meta name=description content="¿Por qué escribir sobre Stack y Heap cuando ya existen pila (pun intended) de artículos en internet? Quiero mejorar mi escritura, y para cumplir este objetivo, decidí escribir artículos sobre cosas que encuentro interesantes. La idea es mejorar mi escritura tanto en inglés (ver arriba a la derecha, hay un link a este mismo artículo en dicho idioma) como en español. Originalmente, este post iba a tratar sobre cómo Rust maneja la memoria a través de lo que se conoce como ownership, pero luego pensé &ldquo;debería primero escribir sobre Stack y Heap&rdquo;."><meta name=author content="Nicolás Antinori"><link rel=canonical href=https://nicoan.github.io/es/posts/stack_and_heap/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://nicoan.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nicoan.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://nicoan.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://nicoan.github.io/apple-touch-icon.png><link rel=mask-icon href=https://nicoan.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://nicoan.github.io/posts/stack_and_heap/><link rel=alternate hreflang=es href=https://nicoan.github.io/es/posts/stack_and_heap/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Stack y Heap"><meta property="og:description" content="¿Por qué escribir sobre Stack y Heap cuando ya existen pila (pun intended) de artículos en internet? Quiero mejorar mi escritura, y para cumplir este objetivo, decidí escribir artículos sobre cosas que encuentro interesantes. La idea es mejorar mi escritura tanto en inglés (ver arriba a la derecha, hay un link a este mismo artículo en dicho idioma) como en español. Originalmente, este post iba a tratar sobre cómo Rust maneja la memoria a través de lo que se conoce como ownership, pero luego pensé &ldquo;debería primero escribir sobre Stack y Heap&rdquo;."><meta property="og:type" content="article"><meta property="og:url" content="https://nicoan.github.io/es/posts/stack_and_heap/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-26T12:00:00-03:00"><meta property="article:modified_time" content="2022-07-26T12:00:00-03:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Stack y Heap"><meta name=twitter:description content="¿Por qué escribir sobre Stack y Heap cuando ya existen pila (pun intended) de artículos en internet? Quiero mejorar mi escritura, y para cumplir este objetivo, decidí escribir artículos sobre cosas que encuentro interesantes. La idea es mejorar mi escritura tanto en inglés (ver arriba a la derecha, hay un link a este mismo artículo en dicho idioma) como en español. Originalmente, este post iba a tratar sobre cómo Rust maneja la memoria a través de lo que se conoce como ownership, pero luego pensé &ldquo;debería primero escribir sobre Stack y Heap&rdquo;."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://nicoan.github.io/es/posts/"},{"@type":"ListItem","position":2,"name":"Stack y Heap","item":"https://nicoan.github.io/es/posts/stack_and_heap/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Stack y Heap","name":"Stack y Heap","description":"¿Por qué escribir sobre Stack y Heap cuando ya existen pila (pun intended) de artículos en internet? Quiero mejorar mi escritura, y para cumplir este objetivo, decidí escribir artículos sobre cosas que encuentro interesantes. La idea es mejorar mi escritura tanto en inglés (ver arriba a la derecha, hay un link a este mismo artículo en dicho idioma) como en español. Originalmente, este post iba a tratar sobre cómo Rust maneja la memoria a través de lo que se conoce como ownership, pero luego pensé \u0026ldquo;debería primero escribir sobre Stack y Heap\u0026rdquo;.","keywords":[],"articleBody":"¿Por qué escribir sobre Stack y Heap cuando ya existen pila (pun intended) de artículos en internet? Quiero mejorar mi escritura, y para cumplir este objetivo, decidí escribir artículos sobre cosas que encuentro interesantes. La idea es mejorar mi escritura tanto en inglés (ver arriba a la derecha, hay un link a este mismo artículo en dicho idioma) como en español. Originalmente, este post iba a tratar sobre cómo Rust maneja la memoria a través de lo que se conoce como ownership, pero luego pensé “debería primero escribir sobre Stack y Heap”.\nPara entender cómo administrar el uso de memoria, primero tenemos que entender qué son el Stack y el Heap. Stack y Heap son regiones de memoria utilizadas por procesos para guardar y leer valores. La memoria de un proceso normalmente se puede dividir en cuatro regiones:\nText: Aquí viven las instrucciones del nuestro programa. El programa ya compilado se carga y guarda en esta región. Data: Todas las variables globales se guardan en esta región. Stack: Es un pedazo contíguo de memoria. En esta región se guardan las variables locales, argumentos y dirección de retorno de las funciones (vamos a ver esto más detalladamente en la próxima sección). Cada hilo de ejecución de un proceso tiene su propio Stack. Heap: Guarda todos los valores de memoria que fueron asignados dinámicamente. Esta región es compartida por todos los hilos de un proceso. Stack El Stack de un proceso es una implementación real de la estructura de datos homónima. Su tamaño es fijo; no podemos pedirle al sistema operativo más memoria. Este tamaño depende principalmente del SO. En sistemas Linux modernos, el tamaño máximo es de 8 MB (esto se puede verificar utilizando el comando ulimit -s)\nDentro del Stack Cada vez que llamamos a una función, un Stack frame (un pedazo de memoria contíguo que contiene toda la información requerida por la función recientemente llamada) es creado y puesto en la parte superior del Stack. Este proceso también sucede de forma inversa, es decir, cada vez que una función termina, el Stack frame es eliminado del Stack, liberando automáticamente toda la memoria utilizada por éste. A continuación veremos un ejemplo simple de cómo el Stack se va llenando. Consideremos el siguiente programa:\nfn sum(a: i32, b: i32) -\u003e i32 { let result = a + b; result } fn square_sum(a: i32, b: i32) -\u003e i32 { let sum_result = sum(a, b); let pow_result = sum_result * sum_result; pow_result } fn main() { let n1 = 2; let n2 = 5; let pow_result = square_sum(n1, n2); println!(\"Result: {}\", pow_result); } El siguiente diagrama representa qué pasa con el Stack cuando el programa es ejecutado:\nAl principio, un Stack frame para la función main es creado. main llama a square_sum, un Stack frame para square_sum es creado. square_sum llama a sum, un Stack frame es creado para sum. Al terminar sum, su Stack frame es destruido, liberando automáticamente toda la memoria ocupada por esta función. Al terminar square_sum, su Stack frame es destruido, liberando automáticamente toda la memoria ocupada por esta función. main imprime el resultado y el programa termina. El sistema operativo libera toda la memoria restante utilizada por el proceso que ejecutaba nuestro programa. NOTA: Normalmente el stack crece hacia abajo!\nDentro del Stack frame El Stack frame es donde todas las variables locales, argumentos y dirección de retorno (ésta es utilizada para saber cuál es la siguiente instrucción a ejecutar luego de que una llamada a función termina) de una función viven. Las buenas noticias son que el usuario no debe preocuparse por asignar o liberar la memoria utilizada por éste (si utilizamos safe Rust, tampoco lo debe hacer para asignaciones en el Heap, pero eso es para otro artículo). Dado que el Stack tiene un tamaño fijo, sólo podemos guardar datos cuyo tamaño es conocido en tiempo de compilación. Para datos de tamaño variable (por ejemplo, vectores), el Heap es utilizado (sólo un puntero a esa parte del Heap y tal vez algo de metadata es guardada en el Stack). A continuación vamos a expandir los diagramas presentados más arriba para mostrar el Stack frame de cada función:\n¿Cómo utilizamos la memoria contenida en un frame? Existen dos punteros que nos ayudan con eso:\nStack Pointer (SP): Siempre apunta al tope del Stack. Cuando un Stack frame es creado, el nuevo valor de SP es SP + size_of(new_Stack_frame). Este valor cambia cada vez que insertamos o quitamos un elemento. Cuando una función termina su ejecución, vuelve al valor que tenía antes de la llamada. Base Pointer (BP): También conocido como Frame Pointer (FP). Apunta a la base del último Stack frame. Cuando un Stack frame es creado, el BP es usado para acceder a los argumentos y variables locales de una función sumando/restando la posición de la variable que queremos acceder respecto al mismo BP. Por ejemplo, si queremos acceder al argumento y, necesitamos leer la dirección BP + 12 porque, primero, tenemos la dirección de retorno que (asumimos) tiene un tamaño de 4 bytes, y luego, tenemos el argumento x, el cuál es un entero de 32 bits (4 bytes). La estructura presentada aquí es sólo un ejemplo. Aunque en la realidad los Stack frames contienen la misma información, cómo los datos son organizados dependen de la arquitectura de la máquina y de la interfaz binaria de aplicación (ABI por sus siglas en inglés).\nEsta respuesta de StackOverflow muestra cómo el Stack frame es construido utilizando x86 assembly.\nHeap En este contexto, “Heap” no tiene nada que ver con la estructura de datos Heap. Es sólo el nombre para la región de memoria “libre”.\nEl Heap no tiene un tamaño fijo. Podemos pedir más memoria, siempre y cuando esté disponible en el sistema, y liberarla si no necesitamos más los valores contenidos en ésta. A diferencia del Stack, cuando trabajamos con el Heap tenemos que admnistrar la asignación/liberación de memoria (en Rust, la mayoría de las asignaciones/liberaciones están escondidas detrás de abstracciones). Cuando utilizamos el Heap, estamos asignando memoria dinámicamente. Esto es muy conveniente cuando trabajamos con datos cuyo tamaño es desconocido en tiempo de compilación (como por ejemplo, texto ingresado por un usuario). Otra diferencia es que, las asignaciones de memoría no son secuenciales.\nCuando un proceso quiere asignar un pedazo de memoria de un tamaño determinado, el sistema operativo primero debe buscar una porción de memoria libre del volumen requerido. Luego de encontrarla, el SO bloquea dicha memoria (sólo el proceso que la pidió la puede acceder) y retorna la dirección correspondiente al primer bloque de ésta. Este proceso nos lleva al problema conocido como fragmentación de memoria (los datos guardados en el Heap no son contíguos).\nCuando utilizamos el Heap, también guardamos algunos datos en el Stack (al menos un puntero a los datos alojados en el Heap). Consideremos el siguiente código:\nfn main() { let n1: Box\u003cu8\u003e = Box::new(42); let my_string = String::from(\"hello\"); println!(\"{} {}\", my_string, n1); } NOTA: Un Box es un puntero inteligente hacia un valor alojado en el Heap.\nEl siguiente diagrama muestra las asignaciones hechas por el programa en el Stack y el Heap:\nEscribir y leer el Heap es más lento que escribir y leer el Stack por varias razones:\nPara la asignación de memoria, un proceso tiene que hacer una llamada al sistema y esperar que el sistema operativo complete el proceso descripto más arriba. Para utilizar la memoria (sea para escribir o leer), tenemos al menos un nivel de indirección (seguir el puntero alojado en el Stack). Bajo las condiciones correctas, un programa puede ser optimizado para guardar algunas partes del Stack dentro de la caché del procesador, haciendo las lecturas/escrituras increíblemente rápidas. Resumen Stack Heap Tamaño fijo Tamaño variable Las asignaciones son contiguas Las asignaciones suceden en orden “aleatorio” Tiempo de acceso rápido Tiempo de acceso lento Es “thread local” por definición Puede ser utilizado para compartir memoria entre procesos ","wordCount":"1316","inLanguage":"es","datePublished":"2022-07-26T12:00:00-03:00","dateModified":"2022-07-26T12:00:00-03:00","author":{"@type":"Person","name":"Nicolás Antinori"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://nicoan.github.io/es/posts/stack_and_heap/"},"publisher":{"@type":"Organization","name":"Nico Antinori","logo":{"@type":"ImageObject","url":"https://nicoan.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://nicoan.github.io/es/ accesskey=h title="Nico Antinori (Alt + H)">Nico Antinori</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://nicoan.github.io/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://nicoan.github.io/es/ title=Home><span>Home</span></a></li><li><a href=https://nicoan.github.io/es/blog/ title=Blog><span>Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Stack y Heap</h1><div class=post-meta><span title='2022-07-26 12:00:00 -0300 -03'>julio 26, 2022</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Nicolás Antinori&nbsp;|&nbsp;Traducciones:<ul class=i18n_list><li><a href=https://nicoan.github.io/posts/stack_and_heap/>English</a></li></ul></div></header><div class=post-content><p>¿Por qué escribir sobre Stack y Heap cuando ya existen pila (<em>pun intended</em>) de artículos en internet? Quiero mejorar mi escritura, y para cumplir este objetivo, decidí escribir artículos sobre cosas que encuentro interesantes. La idea es mejorar mi escritura tanto en inglés (ver arriba a la derecha, hay un link a este mismo artículo en dicho idioma) como en español. Originalmente, este post iba a tratar sobre cómo Rust maneja la memoria a través de lo que se conoce como <a href=https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html>ownership</a>, pero luego pensé &ldquo;debería primero escribir sobre Stack y Heap&rdquo;.</p><p>Para entender cómo administrar el uso de memoria, primero tenemos que entender qué son el Stack y el Heap. Stack y Heap son regiones de memoria utilizadas por procesos para guardar y leer valores. La memoria de un proceso normalmente se puede dividir en cuatro regiones:</p><p><img loading=lazy src=/images/stack/memory.png#center alt="Regiones de memoria"></p><ul><li><strong>Text</strong>: Aquí viven las instrucciones del nuestro programa. El programa ya compilado se carga y guarda en esta región.</li><li><strong>Data</strong>: Todas las variables globales se guardan en esta región.</li><li><strong>Stack</strong>: Es un pedazo contíguo de memoria. En esta región se guardan las variables locales, argumentos y dirección de retorno de las funciones (vamos a ver esto más detalladamente en la próxima sección). Cada hilo de ejecución de un proceso tiene su propio Stack.</li><li><strong>Heap</strong>: Guarda todos los valores de memoria que fueron asignados dinámicamente. Esta región es compartida por todos los hilos de un proceso.</li></ul><h1 id=stack>Stack<a hidden class=anchor aria-hidden=true href=#stack>#</a></h1><p>El Stack de un proceso es una implementación real de la <a href=https://es.wikipedia.org/wiki/Pila_(inform%C3%A1tica)>estructura de datos homónima</a>. Su tamaño es fijo; no podemos pedirle al sistema operativo más memoria. Este tamaño depende principalmente del SO. En sistemas Linux modernos, el tamaño <strong>máximo</strong> es de 8 MB (esto se puede verificar utilizando el comando <code>ulimit -s</code>)</p><h2 id=dentro-del-stack>Dentro del Stack<a hidden class=anchor aria-hidden=true href=#dentro-del-stack>#</a></h2><p>Cada vez que llamamos a una función, un <em>Stack frame</em> (un pedazo de memoria contíguo que contiene toda la información requerida por la función recientemente llamada) es creado y puesto en la parte superior del Stack. Este proceso también sucede de forma inversa, es decir, cada vez que una función termina, el Stack frame es eliminado del Stack, liberando automáticamente toda la memoria utilizada por éste. A continuación veremos un ejemplo simple de cómo el Stack se va llenando. Consideremos el siguiente programa:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>sum</span>(a: <span style=color:#66d9ef>i32</span>, b: <span style=color:#66d9ef>i32</span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>    result
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>square_sum</span>(a: <span style=color:#66d9ef>i32</span>, b: <span style=color:#66d9ef>i32</span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> sum_result <span style=color:#f92672>=</span> sum(a, b);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> pow_result <span style=color:#f92672>=</span> sum_result <span style=color:#f92672>*</span> sum_result;
</span></span><span style=display:flex><span>    pow_result
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> n1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> n2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> pow_result <span style=color:#f92672>=</span> square_sum(n1, n2);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;Result: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, pow_result);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>El siguiente diagrama representa qué pasa con el Stack cuando el programa es ejecutado:</p><p><img loading=lazy src=/images/stack/stack_1.png#center alt="Stack en accion"></p><ol><li>Al principio, un Stack frame para la función <code>main</code> es creado.</li><li><code>main</code> llama a <code>square_sum</code>, un Stack frame para <code>square_sum</code> es creado.</li><li><code>square_sum</code> llama a <code>sum</code>, un Stack frame es creado para <code>sum</code>.</li><li>Al terminar <code>sum</code>, su Stack frame es destruido, liberando automáticamente toda la memoria ocupada por esta función.</li><li>Al terminar <code>square_sum</code>, su Stack frame es destruido, liberando automáticamente toda la memoria ocupada por esta función.</li><li><code>main</code> imprime el resultado y el programa termina. El sistema operativo libera toda la memoria restante utilizada por el proceso que ejecutaba nuestro programa.</li></ol><p><strong>NOTA</strong>: Normalmente el stack crece hacia abajo!</p><h2 id=dentro-del-stack-frame>Dentro del Stack frame<a hidden class=anchor aria-hidden=true href=#dentro-del-stack-frame>#</a></h2><p>El Stack frame es donde todas las variables locales, argumentos y dirección de retorno (ésta es utilizada para saber cuál es la siguiente instrucción a ejecutar luego de que una llamada a función termina) de una función viven. Las buenas noticias son que el usuario no debe preocuparse por asignar o liberar la memoria utilizada por éste (si utilizamos safe Rust, tampoco lo debe hacer para asignaciones en el Heap, pero eso es para otro artículo). Dado que el Stack tiene un tamaño fijo, sólo podemos guardar datos cuyo tamaño es conocido en <a href=https://es.wikipedia.org/wiki/Tiempo_de_compilaci%C3%B3n>tiempo de compilación</a>. Para datos de tamaño variable (por ejemplo, <a href=https://doc.rust-lang.org/std/vec/struct.Vec.html>vectores</a>), el Heap es utilizado (sólo un puntero a esa parte del Heap y <em>tal vez</em> algo de metadata es guardada en el Stack). A continuación vamos a expandir los diagramas presentados más arriba para mostrar el Stack frame de cada función:</p><p><img loading=lazy src=/images/stack/es/stack_2.png#center alt="Stack Frame"></p><p>¿Cómo utilizamos la memoria contenida en un frame? Existen dos punteros que nos ayudan con eso:</p><ul><li><strong>Stack Pointer (SP)</strong>: Siempre apunta al tope del Stack. Cuando un Stack frame es creado, el nuevo valor de SP es <code>SP + size_of(new_Stack_frame)</code>. Este valor cambia cada vez que insertamos o quitamos un elemento. Cuando una función termina su ejecución, vuelve al valor que tenía antes de la llamada.</li><li><strong>Base Pointer (BP)</strong>: También conocido como <em>Frame Pointer (FP)</em>. Apunta a la base del último Stack frame. Cuando un Stack frame es creado, el <em>BP</em> es usado para acceder a los argumentos y variables locales de una función sumando/restando la posición de la variable que queremos acceder respecto al mismo <em>BP</em>. Por ejemplo, si queremos acceder al argumento <code>y</code>, necesitamos leer la dirección <code>BP + 12</code> porque, primero, tenemos la <code>dirección de retorno</code> que (asumimos) tiene un tamaño de 4 bytes, y luego, tenemos el argumento <code>x</code>, el cuál es un entero de 32 bits (4 bytes).</li></ul><p>La estructura presentada aquí es sólo un ejemplo. Aunque en la realidad los Stack frames contienen la misma información, cómo los datos son organizados dependen de la <a href=(https://en.wikipedia.org/wiki/Calling_convention)>arquitectura de la máquina</a> y de la <a href=https://es.wikipedia.org/wiki/Interfaz_binaria_de_aplicaciones>interfaz binaria de aplicación (ABI por sus siglas en inglés)</a>.</p><p><a href=https://stackoverflow.com/questions/3699283/what-is-stack-frame-in-assembly#answer-3700219>Esta respuesta de StackOverflow</a> muestra cómo el Stack frame es construido utilizando x86 assembly.</p><h1 id=heap>Heap<a hidden class=anchor aria-hidden=true href=#heap>#</a></h1><p>En este contexto, &ldquo;Heap&rdquo; no tiene nada que ver con la estructura de datos Heap. Es sólo el nombre para la región de memoria &ldquo;libre&rdquo;.</p><p>El Heap no tiene un tamaño fijo. Podemos pedir más memoria, siempre y cuando esté disponible en el sistema, y liberarla si no necesitamos más los valores contenidos en ésta. A diferencia del Stack, cuando trabajamos con el Heap tenemos que admnistrar la asignación/liberación de memoria (en Rust, <strong>la mayoría</strong> de las asignaciones/liberaciones están escondidas detrás de abstracciones). Cuando utilizamos el Heap, estamos asignando memoria dinámicamente. Esto es muy conveniente cuando trabajamos con datos cuyo tamaño es desconocido en tiempo de compilación (como por ejemplo, texto ingresado por un usuario). Otra diferencia es que, las asignaciones de memoría <strong>no</strong> son secuenciales.</p><p>Cuando un proceso quiere asignar un pedazo de memoria de un tamaño determinado, el sistema operativo primero debe buscar una porción de memoria libre del volumen requerido. Luego de encontrarla, el SO bloquea dicha memoria (sólo el proceso que la pidió la puede acceder) y retorna la dirección correspondiente al primer bloque de ésta. Este proceso nos lleva al problema conocido como <em>fragmentación de memoria</em> (los datos guardados en el Heap <strong>no</strong> son contíguos).</p><p>Cuando utilizamos el Heap, también guardamos algunos datos en el Stack (<em>al menos</em> un puntero a los datos alojados en el Heap). Consideremos el siguiente código:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> n1: Box<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Box::new(<span style=color:#ae81ff>42</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> my_string <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74> </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, my_string, n1);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>NOTA</strong>: Un <a href=https://doc.rust-lang.org/rust-by-example/std/box.html>Box</a> es un <em><a href=https://es.wikipedia.org/wiki/Puntero_inteligente>puntero inteligente</a></em> hacia un valor alojado en el Heap.</p><p>El siguiente diagrama muestra las asignaciones hechas por el programa en el Stack y el Heap:</p><p><img loading=lazy src=/images/stack/es/heap.png#center alt=Heap></p><p>Escribir y leer el Heap es más lento que escribir y leer el Stack por varias razones:</p><ul><li>Para la asignación de memoria, un proceso tiene que hacer una llamada al sistema y esperar que el sistema operativo complete el proceso descripto más arriba.</li><li>Para utilizar la memoria (sea para escribir o leer), tenemos al menos un nivel de indirección (seguir el puntero alojado en el Stack).</li><li>Bajo las condiciones correctas, un programa puede ser optimizado para guardar algunas partes del Stack dentro de la caché del procesador, haciendo las lecturas/escrituras increíblemente rápidas.</li></ul><h1 id=resumen>Resumen<a hidden class=anchor aria-hidden=true href=#resumen>#</a></h1><table><thead><tr><th>Stack</th><th>Heap</th></tr></thead><tbody><tr><td>Tamaño fijo</td><td>Tamaño variable</td></tr><tr><td>Las asignaciones son contiguas</td><td>Las asignaciones suceden en orden &ldquo;aleatorio&rdquo;</td></tr><tr><td>Tiempo de acceso rápido</td><td>Tiempo de acceso lento</td></tr><tr><td>Es &ldquo;thread local&rdquo; por definición</td><td>Puede ser utilizado para compartir memoria entre procesos</td></tr></tbody></table></div><footer class=post-footer><ul class=post-tags></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Stack y Heap on x" href="https://x.com/intent/tweet/?text=Stack%20y%20Heap&amp;url=https%3a%2f%2fnicoan.github.io%2fes%2fposts%2fstack_and_heap%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Stack y Heap on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fnicoan.github.io%2fes%2fposts%2fstack_and_heap%2f&amp;title=Stack%20y%20Heap&amp;summary=Stack%20y%20Heap&amp;source=https%3a%2f%2fnicoan.github.io%2fes%2fposts%2fstack_and_heap%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Stack y Heap on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fnicoan.github.io%2fes%2fposts%2fstack_and_heap%2f&title=Stack%20y%20Heap"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Stack y Heap on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fnicoan.github.io%2fes%2fposts%2fstack_and_heap%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Stack y Heap on whatsapp" href="https://api.whatsapp.com/send?text=Stack%20y%20Heap%20-%20https%3a%2f%2fnicoan.github.io%2fes%2fposts%2fstack_and_heap%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Stack y Heap on telegram" href="https://telegram.me/share/url?text=Stack%20y%20Heap&amp;url=https%3a%2f%2fnicoan.github.io%2fes%2fposts%2fstack_and_heap%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Stack y Heap on ycombinator" href="https://news.ycombinator.com/submitlink?t=Stack%20y%20Heap&u=https%3a%2f%2fnicoan.github.io%2fes%2fposts%2fstack_and_heap%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://nicoan.github.io/es/>Nico Antinori</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>